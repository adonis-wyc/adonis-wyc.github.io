{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"友情链接","date":"2020-04-16T19:34:38.000Z","updated":"2020-04-16T05:14:53.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-16T19:34:57.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-16T19:13:01.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-16T20:46:59.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-16T20:49:23.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-16T20:50:07.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"Java String Class","slug":"Java-String-Class","date":"2020-05-08T23:02:11.000Z","updated":"2020-05-08T23:51:49.000Z","comments":true,"path":"2020/05/08/Java-String-Class/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-String-Class/","excerpt":"","text":"String，StringBuffer，StringBuilder的区别##可变性： String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，没有用final关键字修饰，所以这两种对象都是可变的。 线程安全性String中的对象是不可变的，可以理解为常量，线程安全。 StringBuffer对方法加了同步锁，所以是线程安全的。 StringBuilder没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变时，都会生成一个新的对象，然后将指针指向新的String对象。 StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用StringBuilder比使用StringBuffer仅能获得10%-15%左右的性能提升，但却要冒多线程不安全的风险。 总结操作少量数据：适合用String。 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder。 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。 为什么String是不可变类，有什么好处 字符串常量池的需要：字符串常量池是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假设此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。假如字符串对象允许改变，那么将导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象 允许String对象缓存HashCode：Java中String对象的哈希码被频繁地使用，比如在HashMap等容器中。字符串的不变性保证了哈希码的唯一性，不必每次都去计算新的哈希码，因此可以放心的进行缓存。 安全性：String被许多类当作参数，例如网络链接地址URL，文件路径Path，还有反射机制所需要的参数等，假设String不是固定不变的，将会引起各种安全隐患。","categories":[],"tags":[]},{"title":"Java Lock","slug":"Java-Lock","date":"2020-05-08T21:20:29.000Z","updated":"2020-05-08T23:01:57.000Z","comments":true,"path":"2020/05/08/Java-Lock/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-Lock/","excerpt":"","text":"何为悲观锁，何为乐观锁悲观锁总是假设最坏的情况，每次拿数据都认为别人会修改，所以每次在拿数据的时候都会上锁。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但在更新的时候会判断一下在此期间别人有没有去更新这个数据。 两种锁的适用场景乐观锁适用于读比较多，写比较少的情况下，省去了锁的开销，加大了整个系统的吞吐量。乐观锁适用于写比较多的情况下，一般会经常产生冲突，加锁可以提高效率。 乐观锁常见的两种实现方式 版本号机制：在数据表中加入一个version字段，表示数据被修改的次数，当数据被修改时，version值加一。当线程A要更新数据时，读取数据的同时也会读取version值，在提交更新时，当刚才读取到的version值和当前数据库中的version值相等时才提交更新，否则重试更新操作，直到更新成功。 CAS算法：当需要读写的内存值和进行比较的值相等时，CAS通过原子操作用新值更新内存中的值。 乐观锁的缺点1. ABA问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，不能说明这个变量没有被修改过，因为这段时间他有可能被改为其他值，然后又改回A。 2. 循环时间长开销大不成功的话就一直循环执行直到成功，如果长时间不成功，则会给CPU带来非常大的执行开销。","categories":[],"tags":[]},{"title":"Java Parents delegate","slug":"Java-Parents-delegate","date":"2020-05-08T16:47:41.000Z","updated":"2020-05-08T17:29:26.000Z","comments":true,"path":"2020/05/08/Java-Parents-delegate/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-Parents-delegate/","excerpt":"","text":"Java类加载器主要的类加载器 启动类加载器（BootStrapClassLoader）：该ClassLoader是JVM在启动时创建的，用于加载JAVA_HOME/jre/lib下面的类库。 扩展类加载器（ExtClassLoader）：扩展类加载器会加载JAVA_HOME/jre/ext下的类库。 应用程序类加载器（AppClassLoader）：应用程序类加载器会加载java环境变量CLASSPATH所指定的路径下的类库。 自定义类加载器（CustomClassLoader）：指我们自己定义ClassLoader。 双亲委派机制 当应用程序类加载器加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器扩展类加载器来完成。 当扩展类加载器加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给启动类加载器去完成。 如果启动类加载器加载失败，则会使用扩展类加载器来尝试加载。 若扩展类加载器也加载失败，则会使用应用程序类加载器来加载。 双亲委派机制安全类加载器加载的.class文件来源很多，有的.class文件不可靠，比如可以自定义一个Integer类，里面包含了一些不安全的代码。采用双亲委派机制的话，该Integer类永远不会被调用，因为是由启动类加载器来加载默认的Integer类，而不是自定义的不安全的Integer类。 Java如何打破双亲委派自定义类加载器，继承ClassLoader覆盖loadClass方法。 LoadClass的原顺序为: findLoadedClass 委托parent加载器加载 自行加载 打破双亲委派机制就是要打乱2和3的顺序，通过类名筛选到自己要加载的类，其他的委托给parent加载器。","categories":[],"tags":[]},{"title":"Java reflection","slug":"Java-reflection","date":"2020-05-08T00:03:15.000Z","updated":"2020-05-08T05:48:07.000Z","comments":true,"path":"2020/05/07/Java-reflection/","link":"","permalink":"http://yoursite.com/2020/05/07/Java-reflection/","excerpt":"","text":"Java基础之反射反射的应用 反射可以让开发人员通过外部类的全路径名创建对象，并使用这些类实现一些扩展功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数，成员变量，成员方法。以帮助开发者写出正确的代码。 测试时也可以利用反射API访问类的私有成员，以保证测试代码覆盖率。 反射就是把Java类中的各种成分（包括成员变量，成员方法，构造方法，包等等信息）映射成一个个的Java对象。 如何反射获取Class对象 通过Class.forName加上路径名来获取类对象。 通过类的class属性来获取对象。 通过对象的getClass（）函数来获取对象 其中第一种方法最常见，第二种方法需要倒入类的包，第三种方法已经有Student对象，不需要再反射。 通过反射获取成员变量获取成员变量有两个API：getFields（）和getDeclaredFields（）。区别在于getDeclaredFields用于获取所有声明的字段，包括public, private, protected, defaulted, getFields仅用来获取公有字段。 获取构造方法获取构造方法同样包含了两个API：getConstructors()和getDeclaredConstructors。getConstructors用来获取共有构造方法，getDeclaredConstructors用来获取所有构造方法。 获取成员方法同样包含两个API：getMethods()和getDeclaredMethods()。getMethods()用来获取公有的成员方法，getDeclaredMethods()用来获取所有的成员方法。 参考Java基础之—反射（非常重要) 详解面试中常考的 Java 反射机制","categories":[],"tags":[]},{"title":"garbage collection","slug":"garbage-collection","date":"2020-05-06T18:09:52.000Z","updated":"2020-05-07T05:09:16.000Z","comments":true,"path":"2020/05/06/garbage-collection/","link":"","permalink":"http://yoursite.com/2020/05/06/garbage-collection/","excerpt":"","text":"垃圾回收算法1. 标记-清除算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： 效率问题。 空间问题（标记清除后会产生大量不连续的碎片） 2. 复制算法为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到两一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 3. 标记-整理算法根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 4. 分代收集算法将Java堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都有大量的对象死去，所以可以选择复制算法，只要付出少量对象复制的成本就可以完成每次的垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集。 垃圾收集器1. Serial收集器只会使用一条垃圾收集线程去完成垃圾收集工作，并且在垃圾收集工作的时候必须暂停其他所有的工作线程，直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 2. ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和Serial收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 3. Parallel Scavenge收集器Parallel Scavenge收集器关注点是吞吐量（高效率利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或者最大吞吐量。 新生代采用复制算法，老年代采用标记-整理算法。 4. Serial Old收集器Serial收集器的老年代版本。它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。 5. Parallel Old收集器Parallel 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器 6. CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS收集器HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾回收线程与用户线程（基本上）同时工作。 CMS收集器是一种“标记-清除”算法实现的，它的运作工程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含所有可达对象。因为用户线程可能会不断更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记：重新标记阶段是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。 并发清除：开启用户线程，同时GC线程开始对标记的区域做清扫。 从它的名字可以看出它是一款优秀的垃圾收集器，主要优点：并发收集，低停顿。但是它有下面三个明显的缺点： 对CPU资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片的产生。 G1收集器G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器以及大容量内存的机器，已极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。 此垃圾收集器不需要和别人配合，自己处理新生代和老年代。在JDK9中G1变为Server模式默认的垃圾收集器。它的发明就是为了替代CMS。 G1（Garbage-First）从整体来看是基于标记-整理算法，从局部来看是基于复制算法。相对于CMS它的优点是首先它能建立可预测的停顿时间模型，能在一个规定的时间段内制定垃圾收集的时间不超过限制的毫秒数，并且将Java堆分为多个大小相等的独立区域，它的清理区间不再是整个新生代或者老年代，而是以区域为划分，不会产生空间碎片。 G1会维护一个优先列表，根据跟踪各个region回收所能产生的空间大小和时间来标定优先级，优先回收优先级最大的region。这就等于每次的回收目标更加精确话，提高回收的效率，G1的收集步骤可分为： 初始标记 并发标记 最终标记 筛选回收 初始标记和CMS一样先标记GC Roots直接关联对象，然后并发深入标记，便利关联对象。最终标记和CMS重新标记一个概念，筛选回收就是筛选下决定回收哪个Region价值更大。 参考面试官：谈谈你对JVM垃圾收集器的了解 JVM 垃圾回收","categories":[],"tags":[]},{"title":"Java concurrent II","slug":"Java-concurrent-II","date":"2020-05-03T19:32:32.000Z","updated":"2020-05-08T20:03:28.000Z","comments":true,"path":"2020/05/03/Java-concurrent-II/","link":"","permalink":"http://yoursite.com/2020/05/03/Java-concurrent-II/","excerpt":"","text":"Java并发进阶常见面试题总结1. synchronized关键字1.1 说一说自己对于synchronized关键字的理解synshronized关键字解决的是多个线程访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程在执行。 synchronized关键字加到static静态方法和synchronized（class）代码块上都是给Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。 ###1.2 synchronized关键字的底层原理 synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块结束的位置。 syschronized修饰的方法是用ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。 1.3 谈谈synchronized和ReentrantLock的区别 两者都是可重入锁。“可重入锁”的概念是：自己可以再次获取自己的内部锁。 sysnchronized是依赖于JVM实现的，并没有直接暴露给我们。ReentrantLock是JDK层面实现的，需要lock（）和unlock（）方法配合try／finally语句块来完成。 ReentrantLock比synchronized增加了一些高级功能。主要有三点：（1）等待可中断；（2）实现公平锁（3）可实现选择性通知（锁可以绑定多个条件） ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。 ReentranLock可以制定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓公平锁就是先等待的线程先获得锁。 synchronized关键字与wait（）和notify／notifyAll（）方法相结合实现等待／通知机制。ReentrantLock通过Condition接口与newCondition（）方法实现等待／通知机制。具体实现方法是线程对象注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度上更加灵活。 2. volatile关键字被volatile修饰的共享变量，具有以下两点特性： 保证了不同线程对该变量操作的内存可见性。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主内存，当其他线程需要读取该变量时，会从主存中读取新值。而普通变量则不能保证这一点。 禁止指令重新排序。 3. 可重入锁和非可重入锁的区别不可重入锁：当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。 可重入锁：当前线程获取对象锁之后，该线程可以再次获取本对象上的锁，而其他线程是不可以的。可重入锁的意义在于防止死锁。 4. 线程池线程池就是通过创建一定数量的线程，让他们时刻就绪等待新任务的到达，任务执行结束之后再重新回来继续待命。 4.1 线程池的好处 降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁造成的消耗。 提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性：无限制的创建线程会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一的分配，调优和监控。 4.2 ThreadPoolExecutor构造函数重要参数分析 corePoolSize：定义了最小可以同时运行的线程数量。 maximumPoolSize：队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 keepAliveTime：当线程池中的线程数量大于corePoolSize的时候，如果这时候没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待时间超过了keepAliveTime才会被回收。 unit：KeepAliveTime参数的时间单位。 threadFactory：executor创建线程的时候会用到。 handler：饱和策略。 4.3 ThreadPoolExecutor饱和策略：如果同时运行的线程数量达到最大线程数并且队列已经被放满了任务时，ThreadPoolExecutor定义了一些策略： ThreadPoolExecutor.AbortPolicy: 抛出RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy:调用执行自己的线程运行任务。 TreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢掉。 ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。 4.4 Java中有哪些常用的线程池Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool创建一个定长线程池，可控制线程的最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。 Java中多线程怎么通信 共享变量：线程间可以通过在共享对象的变量里设置信号值来发送信号。比如线程A在一个synchronized的语句块中设置一个boolean的成员变量hasDataToProcess为true，线程B在synChronized语句块中读取hasDataToProcess，如果是true就执行代码，否则就等待。这样就实现了线程A对线程B的通知。 wait/notify()/notifyAll()机制： 一个线程可以对任何一个对象调用wait方法，这样这个线程就会变成wait状态，inactive，等待其他线程在同一个对象上调用notify（）方法，来唤醒这个线程。值得注意的是，在调用wait和notify方法之前，必须要先获得这个对象的锁。","categories":[],"tags":[]},{"title":"JAVA并发基础","slug":"concurrent","date":"2020-05-03T17:48:05.000Z","updated":"2020-05-03T19:26:07.000Z","comments":true,"path":"2020/05/03/concurrent/","link":"","permalink":"http://yoursite.com/2020/05/03/concurrent/","excerpt":"","text":"说说并发和并行的区别 并发：同一时间段内，多个任务都在执行（单位时间内不一定同时执行）。 并行：单位时间内，多个任务同时执行。 为什么要使用多线程先从总体上来说： 从计算机底层来讲：线程的切换和调度成本远远小于进程。在单核CPU时代，多线程主要是为了提高CPU和IO设备的综合利用率；在多核CPU时代，多线程主要是为了提高CPU利用率，让多个CPU核心被利用到。 从互联网发展趋势来讲，现在的系统要求高并发量，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 使用多线程可能带来什么问题肯能会存在：内存泄漏，上下文切换，死锁还有受限于硬件和软件的资源闲置问题。 说说线程的生命周期和状态线程有六个状态：NEW，RUNNABLE，BLOCKED，WAITING，TIME_WAITING，TERMINATED。 什么是上下文切换当前任务执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以加载这个任务的状态。 什么是死锁，如何避免死锁死锁产生的四个条件多个线程同时被阻塞，它们中的一个或多个全部都在等待某个资源被释放。 产生死锁必须具备以下四个条件： 互斥条件：该资源任意时刻只由一个线程占用。 请求于保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其它线程强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如何避免死锁我们只要破坏产生死锁的四个条件中的一个就可以了。 破坏互斥条件这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件一次性申请所有资源 破坏不剥夺条件占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件靠按序申请资源来预防。按照某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。 说说sleep（）方法和wait（）方法的区别和共同点 两者的主要区别是：sleep（）方法没有释放锁，而wait方法释放了锁。 两者都可以暂停进程的执行。 Wait通常用于进程间的交互／通信，sleep（）通常用于暂停执行。 wait（）方法被调用后线程不会自动苏醒，需要别的线程调用同一个对象上的notify（）或者notify（）方法。sleep（）方法执行完成后，线程会自动苏醒。或者可以使用wait（long timeout），超时后线程会自动苏醒。 为什么我们调用start（）方法时会执行run（）方法，为什么我们不能直接调用run（）方法调用start（）方法可以启动线程并使线程进入就绪状态，而run方法只是线程的一个普通方法调用，还是在主线程里执行。","categories":[],"tags":[]},{"title":"Java类加载过程","slug":"Java-class-load-process","date":"2020-05-03T06:36:28.000Z","updated":"2020-05-07T23:56:06.000Z","comments":true,"path":"2020/05/02/Java-class-load-process/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-class-load-process/","excerpt":"","text":"Java类加载过程虚拟机加载Class类型的文件主要分为三步：加载，连接，初始化。连接过程又可分为三步：验证，准备，解析。 加载 通过全类名获取定义此类的二进制字节流。 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。 验证这一步的目的是确保class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机自身的安全。 准备准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都是在方法区中进行分配。 解析解析阶段是将虚拟机常量池内的符号引用替换为直接引用的过程 初始化初始化阶段是执行类构造器方法的过程。","categories":[],"tags":[]},{"title":"Java_memory_area","slug":"Java-memory-area","date":"2020-05-03T05:32:44.000Z","updated":"2020-05-03T06:35:49.000Z","comments":true,"path":"2020/05/02/Java-memory-area/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-memory-area/","excerpt":"","text":"Java内存区域详解运行时的数据区域 程序计数器（Program Counter Register）：作用有两个：（1） 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行，选择，循环，异常处理。（2）在多线程的情况下，程序技术器用来记录当前线程执行位置，从而当线程切换回来的时候能够知道线程上次运行到哪。 Java虚拟机栈：描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。实际上，Java虚拟机栈是由一个个栈帧组成的，每个栈帧中都有局部变量表，操作数栈，动态链接，方法出口信息。其中局部变量表中存放了编译器可知的各种数据类型和对象引用。 本地方法栈：虚拟机使用到的Native方法的内存模型，其余与虚拟机栈非常相似。 堆：此内存区域唯一目的就是存储对象实例，几乎所有的对象实例以及数组都在这里分配内存。 方法区：用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 方法区和永久代的关系方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，是HopSpot的概念。 常用参数JDK1.8之前用PermSize和MaxPermSize来调节方法区大小。 JDK1.8的时候，方法区被移除，取而代之的是元空间，元空间使用的是直接内存。常用参数为MetaspaceSize和MaxMetaspaceSize。 为什么要将永久代替换为元空间？ 永久代有一个JVM本身设置固定大小上限，无法进行调整，容易出现内存溢出，而元空间使用的是直接内存，受本机可用内存限制，比原来出现溢出的概率小。 元空间里面存放的是类的元数据，加载多少类的元数据不由maxpermsize控制，而由系统的实际可用空间来控制，加载类更多了。 在JDK8，合并HotSpot和JRockit代码时，JRockit从来没有一个叫永久代的地方，合并之后就没有必要额外的设置这么一个叫永久代的地方。 运行时的常量池运行时常量池是方法区的一部分，用于存放编译时生成的各种字面量和符号引用。 直接内存直接内存时Java虚拟机之外的内存，但也有可能被Java使用。 在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。 参考链接Java Guide","categories":[],"tags":[]},{"title":"JAVA集合框架","slug":"Java-Collection","date":"2020-05-03T01:12:18.000Z","updated":"2020-05-03T04:34:19.000Z","comments":true,"path":"2020/05/02/Java-Collection/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-Collection/","excerpt":"","text":"#常见集合框架 Java中常见的集合框架有List，Set，Map： List：存储一组不唯一，有序的对象。如ArrayList，LinkedList。 Set：不允许重复的集合，HashSet无序，TreeSet有序。 Map：使用键值对存储。两个Key可以引用相同的对象，但Key不能重复。HashMap无序，TreeMap有序。 ArrayList与LinkedList区别？ ArrayList底层数据结构使用Object数组，LinkedList底层使用的是双向链表数据结构 ArrayList采用数组存储，所以插入和删除元素的时间复杂度受到元素位置的影响。在指定位置插入数据时，时间复杂度为O（n - i）,因为元素i之后的每一个元素都要执行向前／向后移一位的操作。LinkedList采用链表存储，如果要在指定位置i插入和删除元素的话，需要先移动到指定位置再插入或者删除，时间复杂度近似O（n）. ArrayList支持高效快速的随机访问，LinkedList不支持高效快速的随机访问 ArrayList空间浪费主要体现在在list列表结尾会预留一定的容量空间。而LinkedList的空间花费则体现在每一个元素要消耗比ArrayList更多的空间（因为要存放前驱指针，后继指针以及数据）。 HashMap和HashTable的区别 线程是否安全：HashMap是非线程安全的，HashTable是线程安全的。 效率：因为线程安全的问题，HashMap要比HashTable效率高一点。 对Null key和Null value的支持：HashMap中，null可以作为主键，这样的键只有一个，可以有一个或多个键所对应的值为null。 初始容量和每次扩充容量大小的不同：创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n + 1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，HashTable会直接用你给定的大小，而HashMap会将其扩充为2的幂次方大小。 底层数据结构：HashMap在解决哈希冲突时有了较大的变化，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间。","categories":[],"tags":[]},{"title":"线程安全的集合对象","slug":"thread-safe-collection","date":"2020-05-02T18:28:02.000Z","updated":"2020-05-02T23:36:18.000Z","comments":true,"path":"2020/05/02/thread-safe-collection/","link":"","permalink":"http://yoursite.com/2020/05/02/thread-safe-collection/","excerpt":"","text":"线程安全线程安全就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他进程才可以使用。不会出现数据不一致或者数据污染。 线程安全的集合对象 ArrayList线程不安全，Vector线程安全。 HashMap线程不安全，HashTable线程安全。 StringBuilder线程不安全，StringBuffer线程安全。 把非线程安全的集合转换为线程安全可以用Collections.synchronizedList，把ArrayList转化为线程安全的List。与此类似的，还有HashSet，LinkedList，HashMap等等非线程安全的类。","categories":[],"tags":[]},{"title":"Java fundamentation","slug":"Java-fundamentation","date":"2020-05-02T00:33:24.000Z","updated":"2020-05-03T04:34:12.000Z","comments":true,"path":"2020/05/01/Java-fundamentation/","link":"","permalink":"http://yoursite.com/2020/05/01/Java-fundamentation/","excerpt":"","text":"JAVA基础HashMap面试指南###看过HashMap源码嘛，知道原理吗？ HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转换成红黑树。 为什么用数组+链表？ 数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到。 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组对应位置形成一条链表。 用LinkedList代替数组结构可以么?是可行的，但是用数组的效率最高。在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。得到桶的位置，数组的查找效率比LinkedList高。采用基本的数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算时候效率高。而ArrayList的扩容机制是1.5倍扩容。 HashMap在什么条件下扩容？如果bucket数量超过了load factor * current capacity, 就要扩容。load factor为0.75，current capacity为当前数组大小。 为什么扩容是2的次幂?HashMap再分配数据到对应链表时，进行取模运算，但是这种运算不如位运算快，所以在源码中做了优化，将hash%length取模改成hash&amp;(length - 1), 2的n次方-1的二进制实际上就是n个1，保证hash值与（length - 1）做与运算的时候，每一位都能&amp;1，保证了不同位置不会发生碰撞。 Hash值为什么将HashCode的高十六位与第十六位进行异或操作？减小hash值的碰撞几率。 讲讲HashMap的put过程？对key的hashcode做hash运算得到index，如果没碰撞直接放到bucket里；如果碰撞了，以链表形式存在bucket后；如果碰撞导致链表过长，就把链表转化成红黑树，如果节点已经存在就替换之前的value，如果bucket满了就要扩容。 讲讲HashMap的get过程？对key的hashcode做hash运算 HashMap多线程操作导致死循环问题主要原因在于并发下的Rehash会造成元素之间形成循环链表，造成死循环。","categories":[],"tags":[]},{"title":"cluster index VS non cluster index","slug":"cluster-index-VS-non-cluster-index","date":"2020-05-02T00:20:00.000Z","updated":"2020-05-02T00:31:55.000Z","comments":true,"path":"2020/05/01/cluster-index-VS-non-cluster-index/","link":"","permalink":"http://yoursite.com/2020/05/01/cluster-index-VS-non-cluster-index/","excerpt":"","text":"聚集索引和非聚集索引的区别 聚集索引表记录的排列顺序与索引的排列顺序一致，聚集索引一般是表中的主键索引，如果表中没有指定主键，则会选择第一个不允许为null的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。 非聚集索引索引项顺序存储，但是索引项对应的内容却是随机存储的，可以通过非聚集索引查到记录所对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。","categories":[],"tags":[]},{"title":"如何对一条SQL语句进行调优","slug":"optimize-sql","date":"2020-05-01T17:10:38.000Z","updated":"2020-05-01T23:27:22.000Z","comments":true,"path":"2020/05/01/optimize-sql/","link":"","permalink":"http://yoursite.com/2020/05/01/optimize-sql/","excerpt":"","text":"如何对一条SQL语句进行调优 尽量选择字段长度较小的列 将where及order by语句中涉及比较频繁的列建立索引 select子句中避免使用“*”，应指定具体的列名。 当只需要一行数据的时候使用limit 1 避免在where子句中使用 ！=或者&lt;&gt;操作符，否则引擎将放弃索引使用全表扫描 in和not in也要慎用，否则会导致全表扫描，对于连续的数值，可以用between代替in 如果查询的两个表大小相当，用in和exists和in差别不大，当子查询表大时，可以用exists，子查询表小的时候用in。not in和not exists相比时，无论哪个表大，用not exists都比not in快，此外not in可能会产生逻辑错误，子查询所返回的记录中不可以有空值。 避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 保证表单数据不超过200w，适时分割表 针对查询较慢的语句，可以使用explain来分析该语句具体的执行情况 避免查询时判断null，否则可能会导致全表扫描，无法使用索引 避免使用%前缀的like查询，否则可能导致全表扫描，可以考虑使用全文索引，全文索引使用分词器将字段分割成一个个token_text，并且记录这些token_text来自表里的那些行，把这些信息记录到索引中，用空间换时间。 能用union all的时候就不用union，union去重合排序的过程要耗费更多的CPU资源。当然，union all的前提条件是两个结果集没有重复数据。 参考链接MYSQL查询SQL语句性能优化方法 浅谈sql中的in与not in,exists与not exists的区别以及性能分析","categories":[],"tags":[]},{"title":"四种隔离级别","slug":"Isolation-Level","date":"2020-04-24T16:57:08.000Z","updated":"2020-04-24T16:57:49.000Z","comments":true,"path":"2020/04/24/Isolation-Level/","link":"","permalink":"http://yoursite.com/2020/04/24/Isolation-Level/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库的四大特性","slug":"database-ACID","date":"2020-04-24T05:47:20.000Z","updated":"2020-04-24T16:52:14.000Z","comments":true,"path":"2020/04/23/database-ACID/","link":"","permalink":"http://yoursite.com/2020/04/23/database-ACID/","excerpt":"","text":"数据库的四大特性事务事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 ACID1. 原子性（Atomicity）事务要么全部提交成功，要么全部失败回滚。 2. 一致性（Consistency）在事务开始前和事务结束后，数据库的完整性约束没有被破坏。 3. 隔离型（Isolation）一个事务所做修改在提交之前，对其他事务是不可见的。 4. 持久性（Durability）一旦事务提交，其所做的修改会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。 事务的ACID特性概念简单，但不是很好理解，主要是因为这几个特性不是平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足，此时只需要满足原子性，就一定能满足一致性。 在并发情况下，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对数据库崩溃的情况。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库引擎","slug":"database-engine","date":"2020-04-23T17:09:11.000Z","updated":"2020-04-23T18:33:23.000Z","comments":true,"path":"2020/04/23/database-engine/","link":"","permalink":"http://yoursite.com/2020/04/23/database-engine/","excerpt":"","text":"在MySQL中，索引属于存储引擎级别的概念，不同的存储引擎对索引的实现方式是不同的，下面介绍MyISAM和InnoDB两个存储引擎的索引实现方式， 1. MyISAM索引实现MyISAM引擎使用的是B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MySAM索引的原理图： 假设表一共有三列，假设以Col1为主键，则上图是MyISAM表的主索引（primary key）。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM索引检索的算法首先按照B+树搜索算法搜索索引，如果指定的key存在，则取出data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的。 #2. InnoDB索引方式 虽然InnoDB也使用B+树作为索引结构，但具体实现方式与MyISAM截然不同。 第一个重大区别是InnoDB的数据文件本身就是按照B+树组织的索引文件，而MyISAM索引文件和数据文件是分离的，索引文件只保存数据记录的地址。InnoDB表数据文件本身就是主索引，B+树的叶节点data域保存了完整的数据记录，这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果没有指定，则MySQL系统会自动选择一个可以唯一表示数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。 第二个与MyISAM索引不同的是InnoDB辅助索引的data域存储相应记录主键的值而不是地址，换句话说，InnoDB的所有辅助索引都引用主键作为data域。 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 InnoDB不建议使用过长的字段作为主键，多长的索引会使辅助索引变得过大。同时不建议使用非单调字段作为主键，因为InnoDB数据文件本身是一棵B+树，非单调的主键会造成在插入新纪录时数据文件为了维持B+树特性而频繁的分裂调整，十分低效，所以选择自增字段作为主键是一个很好的选择。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"-数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库中有哪些索引类型","slug":"database-index-type","date":"2020-04-22T03:39:59.000Z","updated":"2020-04-24T03:42:24.000Z","comments":true,"path":"2020/04/21/database-index-type/","link":"","permalink":"http://yoursite.com/2020/04/21/database-index-type/","excerpt":"","text":"Mysql索引类型与应用场景1. 索引的数据结构1. B+树为什么使用B+树：检索一次最多需要访问h个节点，数据库系统的设计者利用磁盘预读的原理，将一个节点的大小设计成等于一个页，每次新建节点时都申请一个页的空间，保证一个节点物理上存储到一个页里，加之计算机存储分配都是按页对齐的，这样每个节点一次I／O就可以完全载入，B+树在实际应用中的出度非常大，所以高度很小。综上所述，B+树作为索引结构效率非常高。 2. Hash索引（只有Memory存储引擎支持） Hash索引使用Hash算法，把键值转换成Hashcode，存放在索引中，同时哈希表中保存指向每个数据的指针。在检索时一次定位。 Hash 索引只支持等值查询，仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用例如”&gt;”, “LIKE”操作符的范围查询。在没有大量键值重复的前提下，效率有明显的优势。 hash索引无法利用索引进行排序。 不支持多列索引中的最左前缀原则，无法进行部分匹配查找，因为哈希索引使用索引列的全部内容计算哈希值。不过B+树索引因为支持最左前缀原则，支持部分匹配查找。 在有大量重复键值的情况下，哈希冲突很多，维护索引操作的代价也很高，效率变低。 总结：如果是等职查询，哈希索引有绝对优势， 2. 索引的类型 普通索引：最基本的索引，没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值（注意与主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 全文索引（FULLTEXT）：全文索引仅可用于MyISAM表，他们可以从CHAR，VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或者是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更快。 单列索引、多列索引：多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）：对多个列建立索引，遵循最左前缀原则：最左优先，只从最左边的开始组合。 参考文献深入理解索引底层实现","categories":[],"tags":[]},{"title":"top k frequent","slug":"top-k-frequent","date":"2020-04-22T03:14:16.000Z","updated":"2020-04-22T03:34:10.000Z","comments":true,"path":"2020/04/21/top-k-frequent/","link":"","permalink":"http://yoursite.com/2020/04/21/top-k-frequent/","excerpt":"","text":"寻找数据流中出现最频繁的k个元素（find top k frequent items in a data stream）,这个问题也叫heavy hitter。 方案一：HashMap + Heap用一个HashMap记录每个元素出现的次数，用一个小根堆统计目前出现最频繁的k个元素。具体操作如下： 每次来一个元素，如果在HashMap里已经存在，则把对应的计数器加1；如果不存在，则把元素插入HashMap中，并把相应的计数器设置为1. 在堆中查找该元素，如果存在，则把堆里的计数器也加1，并调整堆；如果没有找到，则把这个元素的次数和堆顶元素进行比较，如果大于堆顶元素出现的次数，则用此元素替换堆顶元素，并调整堆。 空间复杂度O(n)。HashMap需要存放下所有元素，需要O(n)的空间，堆需要存放k个元素，需要O(k)的空间，跟O(n)相比可以忽略不急，总的时间复杂度是O(n) 间复杂度O(n)。每次来一个新元素，需要在HashMap里查找一下，需要O(1)的时间；然后要在堆里查找一下，O(k)的时间，有可能需要调堆，又需要O(logk)的时间，总的时间复杂度是O(n(k+logk))，k是常量，所以可以看做是O(n)。 如果元素数量巨大，单机内存存不下，怎么办？ 方案二： 多机 HashMap + Heap 可以把数据进行分片，假设有8台机器，第1台机器只处理hash(elem)%8==0的元素，第2台机器只处理hash(elem)%8==1的元素，以此类推。 每台机器都有一个HashMap和一个 Heap, 各自独立计算出 top k 的元素。 把每台机器的Heap，通过网络汇总到一台机器上，将多个Heap合并成一个Heap，就可以计算出总的 top k 个元素了。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Huffman","slug":"Huffman","date":"2020-04-22T01:37:35.000Z","updated":"2020-04-22T02:56:44.000Z","comments":true,"path":"2020/04/21/Huffman/","link":"","permalink":"http://yoursite.com/2020/04/21/Huffman/","excerpt":"","text":"霍夫曼编码霍夫曼编码的目的是根据使用频率最大化节省字符编码的存储空间，同时可以避免二义性（因为前缀都是内节点，不携带关键数据），主要应用在数据压缩，加密解密等场合。 简单的理解就是，加入有A, B, C, D,, E五个字符，出现的频率分别为5，4，3，2，1，那么第一步先取两个最小权值作为左右子树构造新树，新生成权值为1+2 = 3的节点，再把新生成的节点放到剩下的集合中，再重复以上步骤，取最小的两个权值构成新树。","categories":[{"name":"-计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡二叉树 vs 红黑树","slug":"AVL-vs-RBT","date":"2020-04-19T17:15:47.000Z","updated":"2020-04-20T00:10:46.000Z","comments":true,"path":"2020/04/19/AVL-vs-RBT/","link":"","permalink":"http://yoursite.com/2020/04/19/AVL-vs-RBT/","excerpt":"","text":"AVL树AVL树是一种平衡二叉树，有两个性质： 左右子树高度差小于一 每一个子树均为平衡二叉树 AVL树查找，插入和删除操作具体方式 查找，插入和删除操作的时间复杂度均为Olog(n), 当执行插入或删除操作时，会造成AVL树的不平衡，通过左旋和右旋来恢复平衡。 红黑树也是一种平衡二叉树，有五个性质： 每个节点要么是红色，要么是黑色 根节点是黑色 每个叶子节点（NIL）是黑色 每个红色节点的两个子节点一定都是黑色 任意一个节点到每个可达到的叶子节点的路径都包含数量相同的黑色节点 红黑树查找，插入和删除操作具体方式 查找，插入和删除操作的时间复杂度均为Olog(n),当执行插入或删除操作时，会造成红黑树的不平衡，通过变色，左旋，右旋来恢复平衡。 AVL树和红黑树的区别 AVL树是严格平衡，红黑树不追求完美平衡，所以二者在查找，插入，删除节点时的效率不同 插入节点导致失衡的情况来说，AVL树和红黑树都是最多两次旋转来恢复平衡。但是就删除节点来说，AVL需要维护被删除节点到根节点这条路径上所有节点的平衡，旋转量级为O(logn), 而红黑树最多只需要旋转3次恢复平衡，旋转量级为O(1)。就查找来讲，AVL树遵循严格平衡，查找效率更高，不过红黑树最多多出一层的查找时间。 AVL树针对读取操作时间较快，维护平衡较慢，空间开销大；红黑树读取略慢，维护平衡较快，内容极多时空间开销略优于AVL树。在实际应用中，如果搜索次数远远大于插入和删除，那么选择AVL，如果搜索，插入和删除次数几乎差不多，应该选择红黑树。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"解决哈希冲突常用方法分析","slug":"hash-conflict-solution","date":"2020-04-18T02:12:44.000Z","updated":"2020-04-18T03:33:45.000Z","comments":true,"path":"2020/04/17/hash-conflict-solution/","link":"","permalink":"http://yoursite.com/2020/04/17/hash-conflict-solution/","excerpt":"","text":"解决哈希冲突的方法解决哈希冲突的方法一般有：开放定址法、链地址法、再哈希法，建立公共溢出区等方法。 1. 开放定址法(Open Adressing)1.1 线性探查法(Linear Probing)从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探测完全部单元为止。 f(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1) 1.2 二次探查法（Quadratic Probing）在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。 f(key) = (f(key)+di) MOD m (di = 1^2, -1^2, 2^2, -2^2,……, q^2, -q^2, q &lt;= m/2) 1.3 双散列函数探查法（Double Hashing）这种方法使用两个散列函数，第一个哈希函数的散列值为初始地址，第二个哈希函数的散列值为地址增量，一次递增，找到空闲单元。 f(key) = (f1(key) + di) MOD m (di = 1 * f2(key), 2 * f2(key),……, (m - 1) * f2(key)) 2. 链地址法将哈希值相同的元素构成一个单链表，存放在哈希表相对应的单元上。链地址法适用于经常进行插入和删除的情况。 3.再哈希法同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 4. 建立公共溢出区这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"bucket sort","slug":"bucket-sort","date":"2020-04-18T00:36:02.000Z","updated":"2020-04-18T01:44:59.000Z","comments":true,"path":"2020/04/17/bucket-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/bucket-sort/","excerpt":"","text":"桶排序之计数排序： 得到无序数组的取值范围 根据取值范围创建对应数量的桶 遍历数组，把每个元素放到对应的“桶”中 按照顺序遍历桶中的每个元素，依次放到数组中，即可完成数组的排序","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"希尔排序（shell_sort）","slug":"shell-sort","date":"2020-04-17T17:50:37.000Z","updated":"2020-04-18T00:08:59.000Z","comments":true,"path":"2020/04/17/shell-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/shell-sort/","excerpt":"","text":"步骤：按一定的增量对数据进行分组，然后对每组进行插入排序，不断减小增量直至增量为1，进行插入排序后整个数据为有序。 123456789101112131415class Solution &#123; public int[] sortArray(int[] nums) &#123; for(int gap = nums.length/2; gap &gt; 0; gap = gap/2)&#123; for(int i = gap; i &lt; nums.length; i++)&#123; int tmp = nums[i]; int j; for(j = i - gap; j &gt;= 0 &amp;&amp; nums[j] &gt; tmp; j = j - gap)&#123; nums[j + gap] = nums[j]; &#125; nums[j + gap] = tmp; &#125; &#125; return nums; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"insertion_sort","slug":"insertion-sort","date":"2020-04-17T17:27:25.000Z","updated":"2020-04-17T17:50:14.000Z","comments":true,"path":"2020/04/17/insertion-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/insertion-sort/","excerpt":"","text":"步骤：每次选择一个元素，将这个元素与之前所有元素比较放在正确的位置上。 12345678910111213class Solution &#123; public int[] sortArray(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++)&#123; int tmp = nums[i]; int j; for(j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; tmp; j--)&#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = tmp; &#125; return nums; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"冒泡排序（bubble_sort）","slug":"bubble-sort","date":"2020-04-17T17:13:34.000Z","updated":"2020-04-17T17:51:37.000Z","comments":true,"path":"2020/04/17/bubble-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/bubble-sort/","excerpt":"","text":"步骤：每次选择两个元素，按照需求进行交换（需要升序排列的话，把较大的元素放在靠后一些的位置），循环n次，这样小的元素会不断的冒泡到前面来，大的元素移动到后面去。 1234567891011121314151617181920class Solution &#123; public int[] sortArray(int[] nums) &#123; boolean ifswap = true; while(ifswap)&#123; ifswap = false; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i + 1])&#123; swap(nums, i, i + 1); ifswap = true; &#125; &#125; &#125; return nums; &#125; private void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"归并排序（merge sort）","slug":"merge-sort","date":"2020-04-17T16:41:32.000Z","updated":"2020-04-17T17:10:00.000Z","comments":true,"path":"2020/04/17/merge-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/merge-sort/","excerpt":"","text":"步骤：如果只有一个元素的情况下直接返回，将数组分成长度尽可能相等的两部分，对左右两部分分别归并排序，然后有序的合并在一起。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;Integer&gt; sortArray(int[] nums) &#123; sort(nums, 0, nums.length - 1, new int[nums.length]); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int num : nums)&#123; result.add(num); &#125; return result; &#125; public void sort(int[] nums, int start, int end, int[] tmp)&#123; if(start &gt;= end)&#123; return; &#125; int mid = (start + end)/2; sort(nums, start, mid, tmp); sort(nums, mid + 1, end, tmp); merge(nums, start, mid, end, tmp); &#125; public void merge(int[] nums, int start, int mid, int end, int[] tmp)&#123; int left = start; int right = mid + 1; int index = start; while(left &lt;= mid &amp;&amp; right &lt;= end)&#123; if(nums[left] &lt;= nums[right])&#123; tmp[index++] = nums[left++]; &#125;else&#123; tmp[index++] = nums[right++]; &#125; &#125; while(left &lt;= mid)&#123; tmp[index++] = nums[left++]; &#125; while(right &lt;= end)&#123; tmp[index++] = nums[right++]; &#125; for(int i = start; i &lt;= end; i++)&#123; nums[i] = tmp[i]; &#125; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"快速排序（quick select）","slug":"quick_select","date":"2020-04-17T05:33:41.000Z","updated":"2020-04-17T05:57:25.000Z","comments":true,"path":"2020/04/16/quick_select/","link":"","permalink":"http://yoursite.com/2020/04/16/quick_select/","excerpt":"","text":"步骤：选取中间元素，把整个数组分成两部分，小于该元素的放在左边，大于该元素的放在右边，分别对左右两边的子数组重复上述操作，直至所有元素有序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;Integer&gt; sortArray(int[] nums) &#123; sort(nums, 0, nums.length - 1); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int num : nums)&#123; result.add(num); &#125; return result; &#125; //quick sort public void sort(int[] nums, int start, int end)&#123; int left = start; int right = end; if(left &gt;= right)&#123; return; &#125; int mid = (left + right)/2; int pivot = nums[mid]; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; &#125; &#125; sort(nums, start, right); sort(nums, left, end); &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"堆排序","slug":"heap_sort","date":"2020-04-17T02:51:24.000Z","updated":"2020-04-17T04:47:32.000Z","comments":true,"path":"2020/04/16/heap_sort/","link":"","permalink":"http://yoursite.com/2020/04/16/heap_sort/","excerpt":"","text":"步骤一：将无序数列构建成最大堆（一般升序采用最大堆，降序采用最小堆）\\ 从最后一个非叶子节点（length/2 - 1）开始，从右至左，从下到上，依次进行调整： 此时将无序序列构建成一个最大堆。 步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。继续调整堆，重复这个过程，直到遍历到第一个元素。 代码实现 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] sortArray(int[] nums) &#123; heapify(nums, nums.length - 1); for(int i = nums.length - 1; i &gt; 0; i--)&#123; int tmp = nums[i]; nums[i] = nums[0]; nums[0] = tmp; siftdown(nums, 0, i - 1); &#125; return nums; &#125; private void heapify(int[] nums, int end)&#123; for(int i = (end + 1)/2 - 1; i &gt;= 0; i--)&#123; siftdown(nums, i, end); &#125; &#125; private void siftdown(int[] nums, int k, int end)&#123; while(2 * k + 1 &lt;= end)&#123; int maxSon = 2 * k + 1; if(2 * k + 2 &lt;= end &amp;&amp; nums[2*k + 2] &gt; nums[maxSon])&#123; maxSon = 2 * k + 2; &#125; if(nums[k] &gt; nums[maxSon])&#123; break; &#125; int tmp = nums[k]; nums[k] = nums[maxSon]; nums[maxSon] = tmp; k = maxSon; &#125; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-16T05:11:12.000Z","updated":"2020-04-16T20:17:45.000Z","comments":true,"path":"2020/04/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-04-11T18:49:16.000Z","updated":"2020-04-16T22:47:23.000Z","comments":true,"path":"2020/04/11/计算机网络/","link":"","permalink":"http://yoursite.com/2020/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络从URL输入到页面展现到底发生了什么？ DNS服务将域名解析成IP地址 TCP三次握手建立连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 TCP四次挥手断开连接 DNS（域名解析）1. IP地址IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，一次来屏蔽物理地址的差异。域名与IP地址对应，与IP地址的一组纯数字相比，用字母配合数字的表示形式更符合人类的记忆习惯。 2. 什么是域名解析DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务 3. DNS解析流程 浏览器缓存：浏览器会按照一定频率缓存DNS记录 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就去操作系统中找 路由缓存：路由器也有DNS缓存。 ISP的DNS服务器：ISP有专门的应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，向根服务器发出请求，进行递归查询（先问根域名服务器.com域名服务器的地址，然后再问。baidu域名服务器，以此类推） ![](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411194229592.png) 服务器处理请求并返回HTTP报文1. 服务器服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。 ![image-20200411195034559](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411195034559.png) 2. MVC后台处理阶段后台开发有很多框架，大部分是按照MVC设计模式进行搭建的。将应用程序分为三个核心部件：模型（model）-视图（view）-控制器（controller）。 ![image-20200411200029387](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411200029387.png) 1. 视图（view）提供给用户的操作界面。 #####2. 模型（model） 负责数据交互。 3. 控制器（controller）属于管理者的角色，从视图接受请求请决定调用哪个模型去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍浏览器渲染机制 ![image-20200411202942762](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411202942762.png) 根据HTML解析DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每个节点的信息 根据计算好的信息绘制页面 OSI七层模型 应用层：能够产生网络流量和用户交互的应用程序 表示层：加密 压缩 开发人员需要考虑的问题 会话层：服务器和客户端建立的会话 查木马 传输层：可靠传输（建立会话） 不可靠传输（微信） 流量控制 网络层：IP地址编址 选择最佳路径 数据链路层： 规定数据如何封装 添加物理层地址 物理层： 规定电压 接口标准 TCP／IP协议模型 应用层 对应OSI中的应用层，表示层，会话层。应用层决定了向用户提供应用服务时通信的活动。包括HTTP，FTP，DNS服务。 传输层 为两台主机上的应用程序提供端到端的通信。有两个互不相同的传输协议：TCP和UDP。 网络层 也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP／IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议，以及IGMP协议。 链路层 也称作数据链路层和网络接口层,通常包括操作系统中的设备驱动程序和极端及对应的网络接口卡，一起处理电缆的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层的地址。 TCP的三次握手和原因 首先服务器端属于LISTEN（监听）状态，等待客户的连接请求。 客户端向服务器端发送连接请求报文，SYN = 1，ACK = 0，选择一个初始的序号X。 服务器端收到链接请求报文，如果同意建立连接，则向客户端发送连接确认报文，SYN=1，ACK=1，确认号为X + 1, 同时选择一个初始的信号y。 客户端收到服务器端的连接确认报文后，向服务器端发送连接确认报文，序号为X+1，确认号为y + 1 服务器端收到客户端的确认后，连接建立。 ###三次握手的原因 防止失效的连接请求到达服务器，如服务器错误的打开链接，造成服务器端的资源浪费。比如：客户端发送的连接请求报文段在网络中滞留时间过长，就会隔很长时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间后就会重新发送连接请求。但是滞留连接最终还是会到达服务器端。如果不进行第三次握手，服务器端就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。 TCP的四次挥手和原因 第一次挥手：主机1（可以是客户端，也可以是服务器端）向主机2发送一个FIN报文段，表示主机1没有数据要发送给主机2了。 第二次挥手：主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，表示同意主机1的关闭请求。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接。 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接。此时主机1等待2MSL后依然没收到回复，则证明服务器端已正常关闭，此时主机1也可以关闭连接。 四次挥手的原因当主机1发出FIN报文段的时候，只是表示主机1已经没有数据要发送了（主机1告诉主机2，他的数据已经全部发送完毕了）；但是这个时候主机1还是可以接受来自主机2的数据，当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还可以发送数据到主机1；当主机2也发送了FIN报文段，这个时候表示主机2也没有数据要发送了。之后中断这次TCP连接。 ##TCP与 UDP TCP传送的协议数据单元是 TCP 报文段（segment） UDP传送的协议数据单元是 UDP 报文 或用户数据报 TCP如何实现可靠传输TCP首先采用三次握手建立连接，四次挥手释放连接。其次TCP采用连续ARQ协议来保证数据传输的正确性，使用滑动窗口协议来保证接收方能够及时处理接收到的数据，进行流量控制。最后TCP使用慢开始，拥塞避免，快重传，快恢复来进行拥塞控制，避免网络拥堵。 连续ARQ协议连续ARQ协议指发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可以连续发送出去，中途不需要等待对方确认。这样可以提高信道的利用率。发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。 接收方采取累计确认的方法，不需要对收到的分组逐个发送确认，而是在收到几个分组后，对按顺序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到了。 TCP滑动窗口窗口是缓存的一部分，用来存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接受窗口的每个字节都允许被接收。如果发送窗口左部的字节已经发送并且得道了确认，就将发送窗口左移，直到左部第一个字节不是一发送并且已确认的状态。接受窗口类似。 TCP流量控制接收方发送的确认报文中的窗口字段可以控制发送窗口的大小，从而影响发送方的发送速率。 TCP拥塞控制如果网络出现拥塞，分组将丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。应该控制发送方的速率。 ![image-20200412133717718](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412133717718.png) TCP主要通过四个算法来进行拥塞控制：慢开始，拥塞避免，快重传，快恢复。 发送方需要维护一个叫做拥塞窗口的状态变量。 1. 慢开始与拥塞避免发送的最初执行慢开始，令cwnd = 1，发送方指发送一个报文段；当收到确认后，将cwnd加倍，因此之后发送方能够发送的报文段数量为：2，4， 8… 慢开始每一轮都将cwnd加倍，发送方发送的速度增长过快，网络拥塞可能性更高。设置一个慢开始门限ssthresh，当send &gt;=ssthresh时，进入拥塞避免，每个轮次只将cwnd加1。如果出现超时，则令ssthresh = cwd／2，然后重新执行慢开始。 2. 快重传与快恢复接收方每次接受到报文段都应该对最后一个已收到的有序报文段进行确认，如果发送方收到三个重复确认，就可以判定下一个报文段丢失，此时执行快重传，立即传送下一个报文段。 这种情况下执行快恢复，令ssthresh = cwnd／2，cwnd = ssthresh，此时直接进入拥塞避免。 ![image-20200412135352055](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412135352055.png) TCP与HTTP区别Tcp对应传输层，Http对应应用层，Http协议作用于Tcp协议之上。当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求，Http会通过Tcp建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将Tcp连接断开。 SocketSocket是应用层与TCP／IP协议族通信的中间软件抽象层，它是一组接口，把复杂的TCP／IP协议族隐藏在Socket接口后面。 HTTPHTTP是什么？通俗地讲，HTTP是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP／IP协议传输数据。 四个基于：请求与响应：客户端发送请求，服务器端响应数据 无状态：客户端向服务器端发起请求时，每次都是建立一个新的连接。每次请求结束后，连接就关闭，相关的内容就释放了，记不住任何状态，成为无状态连接。 应用层：Http属于应用层协议，配合TCP／IP使用。 TCP／IP：Http使用TCP作为它的支撑运输协议。HTTP客户端发起一个与服务器的TCP连接。 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据组成。 ![image-20200411114814725](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411114814725.png) 1. 请求行（request line）请求行分为三部分：请求方法，请求地址，协议版本。 ####2.请求头部 请求头部为报文添加一些附加信息，由“名／值”对组成，每行一对，名和值之间使用冒号分隔。请求头部的最后会后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求头部可选部分，比如GET请求就没有请求数据。 HTTP响应报文HTTP响应报文主要由状态行，响应头部，空行以及响应数据组成。 1. 状态行由三部分组成，分别为：协议版本，状态码，状态码描述 2. 响应头部与请求头部类似，为响应报文添加了一些附加信息 3. 响应数据用于存放需要返回给客户端的数据信息 HTTPS中的对称加密和非对称加密对称加密就是加密和解密用的是同一个密钥k。 非对称加密是发送端使用公开的公钥a加密，然后接收端使用私密的私钥b解密。 HTTPS请求的过程 首先，浏览器请求一个url，找到服务器，向服务器发起一个请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类及其他相关信息返回客户端。 浏览器检查CA证书是不是由可以信赖的CA机构颁发的，确认证书有效和此证书实测网站的。如果不是，给客户端发一个警告，询问是否继续访问。 如果是，客户端使用公钥加密一个随机对称密钥，包括加密的URL一起发送到服务器。 服务器用自己的私钥解密了客户端发送的钥匙，然后用内部包含的对称加密的钥匙给你请求的URL连接解密。 服务器用客户端发来的对称钥匙给请求的网页加密。客户端有相同的钥匙，可以解密传送回来的网页。 HTTP协议的发展历程HTTPs和HTTP的区别HTTP协议传输的数据都是未加密的，可以用抓包工具直接抓下来，而HTTPS利用SSL协议对HTTP协议传输的数据进行加密，抓包工具抓下来的是密文，增加了中间人攻击的成本。 HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的，HTTP 无法加密，而HTTPS 对传输的数据进行加密 HTTP 标准端口是80 ，而 HTTPS 的标准端口是443 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层 HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书 HTTP的请求过程![image-20200411125933423](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411125933423.png) GET和POST比较作用GET用于获取资源，POST用于传输实体主体。 ###参数 GET和POST请求都可以使用额外的参数。GET的参数是以查询字符串的形式出现在URL中，因为URL只支持ASCII码，因此GET的参数中如果存在中文等字符就需要先进行编码。并且URL的长度是受限制的（URL最大长度是2048个字符）。POST的参数存储在实体主体中，支持标准字符集。GET所发送的数据是URL的一部分，POST参数不会被保存在浏览器历史或web服务器日志中，所以POST比GET更安全。 安全安全的HTTP方法不会改变服务器状态，也就是说它只是可读的。 GET方法是安全的，POST却不是。POST的目的是传送实体主体内容，这个内容有可能是用户上传的表单数据，上传成功后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 幂等性幂等的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器的状态也是一样的。GET方法是幂等的，POST方法不是。 可缓存性GET能被缓存，POST不能缓存","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统","slug":"operating system","date":"2020-04-05T06:19:31.000Z","updated":"2020-04-16T20:36:17.000Z","comments":true,"path":"2020/04/04/operating system/","link":"","permalink":"http://yoursite.com/2020/04/04/operating%20system/","excerpt":"","text":"operating system线程和进程 拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度。线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程，会引起进程切换。 系统开销方面。创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I／O设备等，所付出的开销远大于创建或撤销进程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小 线程间可以通过直接读取统一进程中的数据进行通信，但是进程通信需要借助IPC 进程调度算法1. 批处理系统批处理系统没有太多的用户操作，调度算法的目标是保证吞吐量和周转时间。（从提交到中止的时间）。 1.1 先来先服务算法 first-come first-served（FCFS）依据进程进入就绪状态的先后顺序排列。 有利于长作业，不利于短作业。因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业需要执行很长时间，造成了短作业等待时间过长。 1.2 短进程优先算法shortest job first（SJF）按估计运行时间最短的顺序进行调度。 长作业一直等待短作业执行完毕，如果一直有短作业来，长作业有可能饿死。 1.3 最短剩余时间优先 shortest remaining time next（SRTN）按剩余时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间做比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。 2. 交互式系统2.1时间片轮转算法将所有就绪进程按照FCFS规则的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片，当时间片用完时，由计时器发出时钟中断，调度程序中止该进程的执行，并将它送往就绪队列的末尾，同时把CPU时间分配给队首进程。 2.2 优先级调度为每个进程分配一个优先级，按照优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 3.3 多级反馈队列设置多个队列，每个队列优先权不同，时间片大小不同。最上面的队列优先级最高，时间片最小。进程在第一个队列没执行完，就会被移到下一个队列。 Linux中几种IO模型（select，poll，epoll）1. 阻塞和非阻塞IO调用阻塞IO会一直阻塞对应的进程直到操作完成。 非阻塞IO会在内核还在准备数据的情况下离开返回。 ###2. 同步和异步IO 同步IO在执行IO操作时进程会被阻塞。 异步IO发起IO操作后，就直接返回再也不理睬，直到内核发送一个信号，告诉进程IO完成。 3. 多路复用IOselect, poll,epoll这个function不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 分页，分段，段页的区别","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"-计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"-数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"-数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}