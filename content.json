{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"友情链接","date":"2020-04-16T19:34:38.000Z","updated":"2020-04-16T05:14:53.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-16T19:34:57.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-16T19:13:01.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-16T20:46:59.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-04-16T05:11:12.000Z","updated":"2020-04-16T20:17:45.000Z","comments":true,"path":"2020/04/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-04-11T18:49:16.000Z","updated":"2020-04-16T20:36:44.000Z","comments":true,"path":"2020/04/11/计算机网络/","link":"","permalink":"http://yoursite.com/2020/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络从URL输入到页面展现到底发生了什么？ DNS服务将域名解析成IP地址 TCP三次握手建立连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 TCP四次挥手断开连接 DNS（域名解析）1. IP地址IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，一次来屏蔽物理地址的差异。域名与IP地址对应，与IP地址的一组纯数字相比，用字母配合数字的表示形式更符合人类的记忆习惯。 2. 什么是域名解析DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务 3. DNS解析流程 浏览器缓存：浏览器会按照一定频率缓存DNS记录 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就去操作系统中找 路由缓存：路由器也有DNS缓存。 ISP的DNS服务器：ISP有专门的应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，向根服务器发出请求，进行递归查询（先问根域名服务器.com域名服务器的地址，然后再问。baidu域名服务器，以此类推） ![image-20200411194229592](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411194229592.png) 服务器处理请求并返回HTTP报文1. 服务器服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。 ![image-20200411195034559](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411195034559.png) 2. MVC后台处理阶段后台开发有很多框架，大部分是按照MVC设计模式进行搭建的。将应用程序分为三个核心部件：模型（model）-视图（view）-控制器（controller）。 ![image-20200411200029387](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411200029387.png) 1. 视图（view）提供给用户的操作界面。 #####2. 模型（model） 负责数据交互。 3. 控制器（controller）属于管理者的角色，从视图接受请求请决定调用哪个模型去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍浏览器渲染机制 ![image-20200411202942762](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411202942762.png) 根据HTML解析DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每个节点的信息 根据计算好的信息绘制页面 OSI七层模型 应用层：能够产生网络流量和用户交互的应用程序 表示层：加密 压缩 开发人员需要考虑的问题 会话层：服务器和客户端建立的会话 查木马 传输层：可靠传输（建立会话） 不可靠传输（微信） 流量控制 网络层：IP地址编址 选择最佳路径 数据链路层： 规定数据如何封装 添加物理层地址 物理层： 规定电压 接口标准 TCP／IP协议模型 应用层 对应OSI中的应用层，表示层，会话层。应用层决定了向用户提供应用服务时通信的活动。包括HTTP，FTP，DNS服务。 传输层 为两台主机上的应用程序提供端到端的通信。有两个互不相同的传输协议：TCP和UDP。 网络层 也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP／IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议，以及IGMP协议。 链路层 也称作数据链路层和网络接口层,通常包括操作系统中的设备驱动程序和极端及对应的网络接口卡，一起处理电缆的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层的地址。 TCP的三次握手和原因 首先服务器端属于LISTEN（监听）状态，等待客户的连接请求。 客户端向服务器端发送连接请求报文，SYN = 1，ACK = 0，选择一个初始的序号X。 服务器端收到链接请求报文，如果同意建立连接，则向客户端发送连接确认报文，SYN=1，ACK=1，确认号为X + 1, 同时选择一个初始的信号y。 客户端收到服务器端的连接确认报文后，向服务器端发送连接确认报文，序号为X+1，确认号为y + 1 服务器端收到客户端的确认后，连接建立。 ###三次握手的原因 防止失效的连接请求到达服务器，如服务器错误的打开链接，造成服务器端的资源浪费。比如：客户端发送的连接请求报文段在网络中滞留时间过长，就会隔很长时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间后就会重新发送连接请求。但是滞留连接最终还是会到达服务器端。如果不进行第三次握手，服务器端就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。 TCP的四次挥手和原因 第一次挥手：主机1（可以是客户端，也可以是服务器端）向主机2发送一个FIN报文段，表示主机1没有数据要发送给主机2了。 第二次挥手：主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，表示同意主机1的关闭请求。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接。 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接。此时主机1等待2MSL后依然没收到回复，则证明服务器端已正常关闭，此时主机1也可以关闭连接。 四次挥手的原因当主机1发出FIN报文段的时候，只是表示主机1已经没有数据要发送了（主机1告诉主机2，他的数据已经全部发送完毕了）；但是这个时候主机1还是可以接受来自主机2的数据，当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还可以发送数据到主机1；当主机2也发送了FIN报文段，这个时候表示主机2也没有数据要发送了。之后中断这次TCP连接。 ##TCP与 UDP TCP传送的协议数据单元是 TCP 报文段（segment） UDP传送的协议数据单元是 UDP 报文 或用户数据报 TCP如何实现可靠传输TCP首先采用三次握手建立连接，四次挥手释放连接。其次TCP采用连续ARQ协议来保证数据传输的正确性，使用滑动窗口协议来保证接收方能够及时处理接收到的数据，进行流量控制。最后TCP使用慢开始，拥塞避免，快重传，快恢复来进行拥塞控制，避免网络拥堵。 连续ARQ协议连续ARQ协议指发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可以连续发送出去，中途不需要等待对方确认。这样可以提高信道的利用率。发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。 接收方采取累计确认的方法，不需要对收到的分组逐个发送确认，而是在收到几个分组后，对按顺序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到了。 TCP滑动窗口窗口是缓存的一部分，用来存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接受窗口的每个字节都允许被接收。如果发送窗口左部的字节已经发送并且得道了确认，就将发送窗口左移，直到左部第一个字节不是一发送并且已确认的状态。接受窗口类似。 TCP流量控制接收方发送的确认报文中的窗口字段可以控制发送窗口的大小，从而影响发送方的发送速率。 TCP拥塞控制如果网络出现拥塞，分组将丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。应该控制发送方的速率。 ![image-20200412133717718](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412133717718.png) TCP主要通过四个算法来进行拥塞控制：慢开始，拥塞避免，快重传，快恢复。 发送方需要维护一个叫做拥塞窗口的状态变量。 1. 慢开始与拥塞避免发送的最初执行慢开始，令cwnd = 1，发送方指发送一个报文段；当收到确认后，将cwnd加倍，因此之后发送方能够发送的报文段数量为：2，4， 8… 慢开始每一轮都将cwnd加倍，发送方发送的速度增长过快，网络拥塞可能性更高。设置一个慢开始门限ssthresh，当send &gt;=ssthresh时，进入拥塞避免，每个轮次只将cwnd加1。如果出现超时，则令ssthresh = cwd／2，然后重新执行慢开始。 2. 快重传与快恢复接收方每次接受到报文段都应该对最后一个已收到的有序报文段进行确认，如果发送方收到三个重复确认，就可以判定下一个报文段丢失，此时执行快重传，立即传送下一个报文段。 这种情况下执行快恢复，令ssthresh = cwnd／2，cwnd = ssthresh，此时直接进入拥塞避免。 ![image-20200412135352055](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412135352055.png) TCP与HTTP区别Tcp对应传输层，Http对应应用层，Http协议作用于Tcp协议之上。当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求，Http会通过Tcp建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将Tcp连接断开。 SocketSocket是应用层与TCP／IP协议族通信的中间软件抽象层，它是一组接口，把复杂的TCP／IP协议族隐藏在Socket接口后面。 HTTPHTTP是什么？通俗地讲，HTTP是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP／IP协议传输数据。 四个基于：请求与响应：客户端发送请求，服务器端响应数据 无状态：客户端向服务器端发起请求时，每次都是建立一个新的连接。每次请求结束后，连接就关闭，相关的内容就释放了，记不住任何状态，成为无状态连接。 应用层：Http属于应用层协议，配合TCP／IP使用。 TCP／IP：Http使用TCP作为它的支撑运输协议。HTTP客户端发起一个与服务器的TCP连接。 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据组成。 ![image-20200411114814725](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411114814725.png) 1. 请求行（request line）请求行分为三部分：请求方法，请求地址，协议版本。 ####2.请求头部 请求头部为报文添加一些附加信息，由“名／值”对组成，每行一对，名和值之间使用冒号分隔。请求头部的最后会后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求头部可选部分，比如GET请求就没有请求数据。 HTTP响应报文HTTP响应报文主要由状态行，响应头部，空行以及响应数据组成。 1. 状态行由三部分组成，分别为：协议版本，状态码，状态码描述 2. 响应头部与请求头部类似，为响应报文添加了一些附加信息 3. 响应数据用于存放需要返回给客户端的数据信息 HTTPS中的对称加密和非对称加密对称加密就是加密和解密用的是同一个密钥k。 非对称加密是发送端使用公开的公钥a加密，然后接收端使用私密的私钥b解密。 HTTPS请求的过程 首先，浏览器请求一个url，找到服务器，向服务器发起一个请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类及其他相关信息返回客户端。 浏览器检查CA证书是不是由可以信赖的CA机构颁发的，确认证书有效和此证书实测网站的。如果不是，给客户端发一个警告，询问是否继续访问。 如果是，客户端使用公钥加密一个随机对称密钥，包括加密的URL一起发送到服务器。 服务器用自己的私钥解密了客户端发送的钥匙，然后用内部包含的对称加密的钥匙给你请求的URL连接解密。 服务器用客户端发来的对称钥匙给请求的网页加密。客户端有相同的钥匙，可以解密传送回来的网页。 HTTP协议的发展历程HTTPs和HTTP的区别HTTP协议传输的数据都是未加密的，可以用抓包工具直接抓下来，而HTTPS利用SSL协议对HTTP协议传输的数据进行加密，抓包工具抓下来的是密文，增加了中间人攻击的成本。 HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的，HTTP 无法加密，而HTTPS 对传输的数据进行加密 HTTP 标准端口是80 ，而 HTTPS 的标准端口是443 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层 HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书 HTTP的请求过程![image-20200411125933423](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411125933423.png) GET和POST比较作用GET用于获取资源，POST用于传输实体主体。 ###参数 GET和POST请求都可以使用额外的参数。GET的参数是以查询字符串的形式出现在URL中，因为URL只支持ASCII码，因此GET的参数中如果存在中文等字符就需要先进行编码。并且URL的长度是受限制的（URL最大长度是2048个字符）。POST的参数存储在实体主体中，支持标准字符集。GET所发送的数据是URL的一部分，POST参数不会被保存在浏览器历史或web服务器日志中，所以POST比GET更安全。 安全安全的HTTP方法不会改变服务器状态，也就是说它只是可读的。 GET方法是安全的，POST却不是。POST的目的是传送实体主体内容，这个内容有可能是用户上传的表单数据，上传成功后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 幂等性幂等的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器的状态也是一样的。GET方法是幂等的，POST方法不是。 可缓存性GET能被缓存，POST不能缓存","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统","slug":"operating system","date":"2020-04-05T06:19:31.000Z","updated":"2020-04-16T20:36:17.000Z","comments":true,"path":"2020/04/04/operating system/","link":"","permalink":"http://yoursite.com/2020/04/04/operating%20system/","excerpt":"","text":"operating system线程和进程 拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度。线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程，会引起进程切换。 系统开销方面。创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I／O设备等，所付出的开销远大于创建或撤销进程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小 线程间可以通过直接读取统一进程中的数据进行通信，但是进程通信需要借助IPC 进程调度算法1. 批处理系统批处理系统没有太多的用户操作，调度算法的目标是保证吞吐量和周转时间。（从提交到中止的时间）。 1.1 先来先服务算法 first-come first-served（FCFS）依据进程进入就绪状态的先后顺序排列。 有利于长作业，不利于短作业。因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业需要执行很长时间，造成了短作业等待时间过长。 1.2 短进程优先算法shortest job first（SJF）按估计运行时间最短的顺序进行调度。 长作业一直等待短作业执行完毕，如果一直有短作业来，长作业有可能饿死。 1.3 最短剩余时间优先 shortest remaining time next（SRTN）按剩余时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间做比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。 2. 交互式系统2.1时间片轮转算法将所有就绪进程按照FCFS规则的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片，当时间片用完时，由计时器发出时钟中断，调度程序中止该进程的执行，并将它送往就绪队列的末尾，同时把CPU时间分配给队首进程。 2.2 优先级调度为每个进程分配一个优先级，按照优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 3.3 多级反馈队列设置多个队列，每个队列优先权不同，时间片大小不同。最上面的队列优先级最高，时间片最小。进程在第一个队列没执行完，就会被移到下一个队列。 Linux中几种IO模型（select，poll，epoll）1. 阻塞和非阻塞IO调用阻塞IO会一直阻塞对应的进程直到操作完成。 非阻塞IO会在内核还在准备数据的情况下离开返回。 ###2. 同步和异步IO 同步IO在执行IO操作时进程会被阻塞。 异步IO发起IO操作后，就直接返回再也不理睬，直到内核发送一个信号，告诉进程IO完成。 3. 多路复用IOselect, poll,epoll这个function不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 分页，分段，段页的区别","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"},{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}