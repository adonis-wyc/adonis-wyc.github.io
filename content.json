{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"友情链接","date":"2020-04-16T19:34:38.000Z","updated":"2020-04-16T05:14:53.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-16T19:34:57.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-16T19:13:01.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-16T20:46:59.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-16T20:49:23.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-16T20:50:07.000Z","updated":"2020-04-16T05:14:53.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"spring框架","slug":"spring框架","date":"2020-06-18T05:45:37.000Z","updated":"2020-06-20T21:59:15.000Z","comments":true,"path":"2020/06/17/spring框架/","link":"","permalink":"http://yoursite.com/2020/06/17/spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Spring IOC控制反转：指创建对象控制权的转移，原本创建对象的时机由自己把握，而现在这种权利转换到spring IOC容器中，spring根据配置文件或者注解创建实例和管理实例之间的依赖关系。 Spring依赖注入 使用构造函数提供。 使用set方法提供。 使用注解提供。 Spring如何解决循环依赖 构造器的循环依赖，无法解决只能抛出异常。 setter注入构成的循环依赖可以解决。使用三级缓存 prototype作用域的bean的循环依赖无法解决。 使用三级缓存： 第一级缓存singletonObjects，存放装配好的单例对象。 第二级缓存earlySingletonObjects，存放没有完全装配好的单例对象。 第三级缓存singletonFacgtories，存放要被装配的对象。 详解：beanA先进行初始化，将自己提前曝光到singletonFactories，发现了对beanB的依赖，进行beanB的初始化过程，在beanB中发现了对beanA的依赖，在singletonFactories中可以获得A的引用，完成装配后将自己放入一级缓存，此后beanA完成了初始化。 Spring的bean初始化过程 createBeanInstance：调用对象的构造方法实例化对象。 populateBean：对bean的依赖属性进行填充。 initalizeBean：调用spring xml中的init方法。 Spring如何实现懒加载设置default-lazy–init = “true”,实现懒加载，beanFactory接口是懒加载。 Spring中bean的作用范围 作用：用于指定bean的作用范围。 ​ 取值： ​ singleton（单例）：整个IOC容器中只有一个bean实例。 ​ prototype（多例）：每次从容器中请求bean，都会产生一个新的bean实例。 ​ request（作用于web应用的请求范围）：每次http请求，都会创建一个新的bean。 ​ session（作用于web应用的会话范围）：同一个http session共享一个bean，不同的session使用不同的bean。 ​ global-session（作用于集群环境的全局会话范围，当不是集群环境时，它就是session）：同一个全局session共享一个bean。 Spring中bean对象的生命周期单例对象： ​ 出生：当容器创建时对象出生。 ​ 活着：只要容器还在，对象一直活着。 ​ 死亡：容器销毁，对象死亡。 ​ 总结：单例对象的生命周期和容器相同。 多例对象： ​ 出生：当我们使用对象时spring框架为我们创建。 ​ 活着：对象在使用过程中就一直活着。 ​ 死亡：当对象长时间不用且没有别的引用时，有Java垃圾回收器回收。 Spring AOP把程序重复的代码抽取出来，在需要执行的时候，使用动态代理技术，在不修改源码的基础上，对已有的方法进行增强。 Spring AOP术语 连接点（JoinPoint）：Spring允许通知的地方，spring只支持方法连接点，和方法有关的前前后后都是连接点。 切入点（Pointcut ）：在连接点中选取几个点作为切入点，真正的放入通知。 通知（Advice）：你想要的功能，也就是上面说的安全，事务，日志。 前置通知（Before advice）： 正常返回通知（After returning advice）: 异常返回通知（After throwing advice）：在连接点抛出异常后执行。 返回通知（After（finally）advice）：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 环绕通知（Around advice）：环绕通知围绕在连接点前后，比如一个方法调用的前后，可以手动控制增强代码何时执行。 切面（Aspect）：切面是通知和切入点的结合。 引入（introduction）：允许我们向现有的类添加新方法属性。 目标（target）：代理的目标对象。 织入（weaving）：把增强应用到目标对象来创建新的代理对象的过程。 代理（Proxy）：一个类被AOP织入增强后，就会产生一个结果代理类。 Spring事务隔离级别 ISOLATION_READ_UNCOMMITTED: 读未提交。 ISOLATION_READ_COMMITTED: 读已提交 。 ISOLATION_REPEATABLE_READ ：可重复读。 ISOLATION_SERIALIZABLE: 串行化 。 默认隔离级别为后端数据库的默认隔离级别。Mysql使用可重复读。Oracle采用读已提交。 Spring事务传播机制当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 PROPAGATION_REQUIRED:当前存在事务就加入事务，没有就创建。 PROPAGATION_SUPPORTS: 当前存在事务就加入事务，没有就以非事务的方式继续运行。 Spring如何通过注解实现事务功能 在配置文件中配置事务管理器。 在配置文件中开启对注解事务的支持。 在需要事务支持的地方使用@Tansactional注解。 Spring常用注解用于创建对象： @component： ​ 作用：用于把当前对象存入spring容器中 ​ 属性：value：用于指定bean的id。当我们不写时，他的默认值是当前类名，且首字母改小写。 @Controller:一般用在表现层。 @Service:一本用在业务层。 @Repository:一般用在持久层。 以上三个注解它们的作用和属性与Component是一模一样的，他们三个是spring框架为我们提供明确的三层使用的注释，使我们的三层对象更加清晰。 用于注入数据： @Autowired： ​ 作用：自动按照类型注入。只要容器中有唯一一个bean对象类型和要注入的变量类型匹配，就可以注入成功。 ​ 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 ​ 如果ioc容器中有多个类型匹配时，要注入的变量名称要和bean对象的key保持一致。 ​ 出现位置：可以是变量上，也可以是方法上。 ​ 细节： ​ 在使用注解注入时，set方法就不是必须的了。 @Qualifer： 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用(要和autowired组合在一起)。但在给方法参数注入时可以。 属性：用于指定注入bean的id。 @Resourse： 作用：直接按照bean的id注入，它可以独立使用。 属性：name用于指定bean的id。 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML实现。 @Value 作用：用于注入基本类型和String类型的数据。 属性：value用于指定数据的值。它可以使用spring中的SpEL（也就是spring的el表达式）SpEL的写法，${表达式} @Bean 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中 属性： ​ name：用于指定bean的id。当不写时，默认值是当前方法名称。 细节： 当我们使用注解配置方法时，如果方法有参数，spring框架回去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。 Spring MVC 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping找到具体的处理器并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter，经过适配调用具体的Controller。 Controller执行完饭回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图。 DispatcherServlet响应用户。 Hibernate和MyBatis的区别 Hibernate拥有完整的Bean对象和数据库的映射结构，MyBatis仅有基本的字段映射，需要写一些特定的sql语句，降低了数据库的可移植性。 Hibernate拥有完整的日志系统，Mybatis则欠缺一些。 Hibernate的配置比MyBatis复杂，，Mybatis使用简单，上手较快，但后期但是要关心很多技术细节。 Hibernate中的sql自动生成，MyBatis的sql都是写在XML里，优化更方便。 mybatis如何防止sql注入首先了解#{}和*{}的区别。 #{}: 对于传入的参数，在预处理阶段会使用？代替，待真正查询的时候才会代入参数。 ${}: 简单替换。 各自特点： #{}用于防止sql注入。 ${}用于传入表名，字段名。 sql注入就是指把用户输入的数据拼接到sql语句后面作为sql语句的一部分执行。","categories":[],"tags":[]},{"title":"分布式","slug":"分布式","date":"2020-06-18T05:08:14.000Z","updated":"2020-06-18T05:11:31.000Z","comments":true,"path":"2020/06/17/分布式/","link":"","permalink":"http://yoursite.com/2020/06/17/%E5%88%86%E5%B8%83%E5%BC%8F/","excerpt":"","text":"CAP理论和base定理","categories":[],"tags":[]},{"title":"redis","slug":"redis","date":"2020-06-06T04:00:57.000Z","updated":"2020-06-21T04:58:06.000Z","comments":true,"path":"2020/06/05/redis/","link":"","permalink":"http://yoursite.com/2020/06/05/redis/","excerpt":"","text":"一. 概述Redis是速度非常快的非关系型、内存、键值数据库。可以存储键和五种不同类型的值之间的映射。 二. 数据类型和使用场景STRING: **存储字符串，整数或者浮点数。使用场景：**可以用作计数器，通过对String的自增自减操作。 LIST: **存储列表。使用场景：**粉丝列表，文章评论列表。 SET: **存储无序集合。使用场景：**可以把两个人的粉丝列表整合成一个交集。 HASH: **存储无序的键值对。使用场景：**将结构化的数据给存储到redis里。 ZSET: **存储有序集合。使用场景：**可以实现排行榜功能。 三. 数据结构字典是无序键值对(HASH)的底层实现之一。使用哈希表作为底层实现。用链地址法解决哈希冲突。 跳跃表是有序集合(ZSET)的底层实现之一。可以看成多个有序链表。插入速度快，因为不需要通过旋转操作维护平衡。查找速度为O(logN)。 搜索：从最高层开始，如果要查找的元素大于当前节点小于下一个节点的值，则取下一层寻找。 插入：首先确定插入的层数k，然后将新元素插入到k层到最底层。 删除：在各个层查找指定的节点，然后将节点从链表中删除。 redis过期淘汰策略redis可以为key设置过期时间，对过期的key，采用定期删除和惰性删除的方式。 定期删除：每隔一段时间检查，随机抽取一些设置过期时间的key，检查是否过期，如果过期，则删除。 惰性删除：一些过期的key，并没有被定期删除删除掉，只有当系统使用并检查过期了，才会将其删除。 Redis有六种数据淘汰策略： volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。 allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰。 allkeys-random：从所有数据集中任意选择数据进行淘汰。 noeviction：禁止驱逐数据。 redis持久化机制为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB持久化：通过创建快照获得某个时间点的数据副本，可以将快照进行备份或者复制到其它机器重用数据。 优点：适合做冷备份，恢复数据速度快。 缺点：实时性不好，可能丢失部分数据，如果文件过大，可能导致服务暂停几秒。 AOF持久化：将写命令添加到AOF文件的末尾。 三种AOF方式： 1. **always**：每次修改都写入AOF中。 2. **everysec**：每秒钟同步一次，多个命令一起写入。 3. **no**，操作系统决定何时同步。优点：实时性好，一般一秒一写入，而且写入性能好。 缺点：AOF文件更大，恢复速度慢。 redis事务redis使用MULTI开始事务，EXEC执行事务，DISCARD取消事务，WATCH监视key等命令实现事务功能。单个redis命令的执行是原子性的，Redis事务的执行并不是原子性的。 缓存雪崩缓存穿透 缓存雪崩：缓存在同一时间内大面积失效，所有请求都落在数据库中，数据库短时间内承受大量请求而崩溃。 解决办法： 事前：保证redis集群的高可用性，发现机器宕机尽快补上。key的过期时间尽可能错开。 事中：使用本地ehcache缓存（先找本地缓存，再找redis，最后找数据库）+ hystrix限流（每秒接受一定量的请求）+ 降级（多余的请求走降级组件） 事后：redis持久化机制，尽快恢复缓存集群，从磁盘中加载数据恢复内存中的数据。 缓存穿透：大量请求的key不存在于缓存中，导致请求直接到了数据库上。 解决办法： 缓存无效的key，意味着占用更多的内存，需要将过期时间设置的很短。 布隆过滤器：将所有可能存在的数据哈希到一个bitMap中，拦截不存在的数据访问。 redis并发竞争key的问题可以利用redis或者zookeeper加分布式锁。 如何保证缓存和数据库的数据一致性 延时双删策略+设置缓存过期时间。 Mysql中产生更新操作，利用消息队列将binlog相关的消息推送至redis，redis根据binlog中的记录，对redis进行更新。 ##redis是单线程还是多线程？为什么那么快？ 操作完全基于内存，速度快。 数据结构简单，对数据的操作简单 采用单线程，避免了不必要的上下文切换开销。 使用多路IO复用模型，效率提高了。 redis热key问题？如何发现以及如何解决？定义：某个key被大量访问，对redis服务器造成了很大压力。 如何发现热key？ 经验预估。 自带命令查询 redis-cli-hotkeys 在操作redis之前对数据进行统计。 解决方案： 将热点数据缓存至服务端的内存中，利用ehchche。 将热点key+随机数利用哈希随机分配至redis其他节点中。 ##redis数据分布方式？有什么优点？一致性hash呢？ redis数据分布没有使用一致性哈希算法，而是使用哈希槽算法。 哈希槽算法具体实现：redis集群一共有16384个哈希槽，所有的key都会被映射到哈希槽中，使用CRC16(key)%16384=哈希槽，每个节点负责不同数量的槽。 一致性哈希算法具体实现：将整个哈希值空间组成一个虚拟圆环，key的哈希函数对2^32取模得到哈希值，在圆环上顺时针旋转，遇到的第一个服务器就是定位到的服务器。增加或删除节点对数据的影响比较小。但在某些极端情况下容易出现严重的数据扎堆，因此提出了虚拟节点，每一个服务器对应多个虚拟节点，分配到虚拟节点其实是分配到对应的服务器上。 普通的哈希分配策略：key的哈希值对服务器数量取模，当一个服务器挂掉，所有数据的都要重新分配，工作量很大。 redis主从复制一个主数据库可以拥有多个从数据库，主数据库可以进行读写操作，从数据库一般是只读操作，并接受主数据库同步过来的数据。 redis主从切换当一台主数据库发生故障时，自动制定一个从数据库变成主数据库。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指offer","slug":"剑指offer","date":"2020-06-05T16:05:42.000Z","updated":"2020-06-21T21:39:53.000Z","comments":true,"path":"2020/06/05/剑指offer/","link":"","permalink":"http://yoursite.com/2020/06/05/%E5%89%91%E6%8C%87offer/","excerpt":"","text":"双指针5. 替换空格12345678910111213141516171819public String replaceSpace(StringBuffer str) &#123; int P1 = str.length() - 1; for (int i = 0; i &lt;= P1; i++) if (str.charAt(i) == ' ') str.append(\" \"); int P2 = str.length() - 1; while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123; char c = str.charAt(P1--); if (c == ' ') &#123; str.setCharAt(P2--, '0'); str.setCharAt(P2--, '2'); str.setCharAt(P2--, '%'); &#125; else &#123; str.setCharAt(P2--, c); &#125; &#125; return str.toString();&#125; 57.1 和为S的两个数字1234567891011121314151617public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int left = 0; int right = array.length - 1; while(left &lt; right)&#123; if(array[left] + array[right] == sum)&#123; result.add(array[left]); result.add(array[right]); return result; &#125;else if(array[left] + array[right] &lt; sum)&#123; left++; &#125;else&#123; right--; &#125; &#125; return result; &#125; 57.2 和为S的连续正数数列滑动窗口的方法：用两个数字start 和end **分别表示序列的最小值和最大值，首先将 start 初始化为1，end 初始化为2。如果从start到end的和大于sum，我们就从序列中去掉较小的值(即增大start),相反，只需要增大end。终止条件为：一直增加begin到(1+sum)/2**并且end小于sum为止 123456789101112131415161718192021222324252627public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); int start = 1; int end = 2; if(sum &lt; 3)&#123; return result; &#125; while(start &lt; (1 + sum)/2)&#123; int totalNum = 0; for(int i = start; i &lt;= end; i++)&#123; totalNum += i; &#125; if(totalNum == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = start; i &lt;= end; i++)&#123; list.add(i); &#125; result.add(list); start++; &#125;else if(totalNum &lt; sum)&#123; end++; &#125;else&#123; start++; &#125; &#125; return result; &#125; 二分法53. 数字在排序数组中出现的次数利用二分法找到第一次出现的位置，然后向后遍历找到最后一次出现的位置 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; if(array == null || array.length == 0)&#123; return 0; &#125; int first = firstPosition(array, k); int last = first; while(last &lt; array.length &amp;&amp; array[last] == k)&#123; last++; &#125; return last - first; &#125; public int firstPosition(int[] array, int k)&#123; int left = 0; int right = array.length - 1; while(left + 1 &lt; right)&#123; int mid = (left + right)/2; if(array[mid] == k)&#123; right = mid; &#125;else if(array[mid] &lt; k)&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; int result = 0; if(array[left] == k)&#123; result = left; &#125;else&#123; result = right; &#125; return result; &#125;&#125; 堆59. 滑动窗口的最大值将窗口内的值放入堆中，窗口滑动过程中不断维护最大堆。 123456789101112131415161718public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(size &gt; num.length || size == 0)&#123; return result; &#125; Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); for(int i = 0; i &lt; size; i++)&#123; maxHeap.add(num[i]); &#125; result.add(maxHeap.peek()); for(int i = size; i &lt; num.length; i++)&#123; maxHeap.remove(num[i - size]); maxHeap.offer(num[i]); result.add(maxHeap.peek()); &#125; return result; &#125; 动态规划：60. n个骰子的点数dp[i] [j]代表前i个骰子总数为j的次数。 123456789101112131415161718192021222324public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) &#123; // Write your code here // Ps. new AbstractMap.SimpleEntry&lt;Integer, Double&gt;(sum, pro) // to create the pair int face = 6; int pointNum = face * n; long[][] dp = new long[n + 1][pointNum + 1]; for(int i = 1; i &lt;= face; i++)&#123; dp[1][i] = 1; &#125; for(int i = 2; i &lt;= n; i++)&#123; for(int j = i; j &lt;= i * face; j++)&#123; for(int k = 1; k &lt;= 6 &amp;&amp; j - k &gt;= 0; k++)&#123; dp[i][j] += dp[i - 1][j - k]; &#125; &#125; &#125; double totalNum = Math.pow(6, n); List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ret = new ArrayList&lt;&gt;(); for(int i = n; i &lt;= pointNum; i++)&#123; ret.add(new AbstractMap.SimpleEntry&lt;&gt;(i, dp[n][i]/totalNum)); &#125; return ret;&#125; 63. 股票的最大的利润思路：本质上不是动态规划，但是由于其follow up所以放入这里。具体思路是遍历数组，用min记录目前的最小值，不断比较得到最大利润。 123456789101112public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0)&#123; return 0; &#125; int min = prices[0]; int maxProfit = 0; for(int i = 0; i &lt; prices.length; i++)&#123; min = Math.min(min, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - min); &#125; return maxProfit;&#125; 链表6. 从头到尾打印链表12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(listNode == null)&#123; return result; &#125; ListNode tail = null; while(listNode != null)&#123; ListNode next = listNode.next; listNode.next = tail; tail = listNode; listNode = next; &#125; listNode = tail; while(listNode != null)&#123; result.add(listNode.val); listNode = listNode.next; &#125; return result; &#125;&#125; 52. 两个链表的第一个公共节点当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 12345678910111213141516171819public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1 != p2)&#123; if(p1 != null)&#123; p1 = p1.next; &#125;else&#123; p1 = pHead2; &#125; if(p2 != null)&#123; p2 = p2.next; &#125;else&#123; p2 = pHead1; &#125; &#125; return p1; &#125;&#125; 二叉树相关：7. 重建二叉树123456789101112131415161718private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; for (int i = 0; i &lt; in.length; i++) indexForInOrders.put(in[i], i); return reConstructBinaryTree(pre, 0, pre.length - 1, 0);&#125;private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) &#123; if (preL &gt; preR) return null; TreeNode root = new TreeNode(pre[preL]); int inIndex = indexForInOrders.get(root.val); int leftTreeSize = inIndex - inL; root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL); root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1); return root;&#125; 8. 二叉树的下一个结点54. 二叉查找树的第k个结点利用中序遍历并查到遍历到的第k个节点 1234567891011121314151617181920public class Solution &#123; int count = 0; TreeNode result; TreeNode KthNode(TreeNode pRoot, int k) &#123; inOrder(pRoot, k); return result; &#125; private void inOrder(TreeNode node, int k)&#123; if(node == null || count &gt;= k)&#123; return; &#125; inOrder(node.left, k); count++; if(count == k)&#123; result = node; &#125; inOrder(node.right, k); &#125;&#125; 55.1 二叉树的深度123456public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1; &#125; 55.2 平衡二叉树123456789101112131415161718public class Solution &#123; boolean isBalanced = true; public boolean IsBalanced_Solution(TreeNode root) &#123; height(root); return isBalanced; &#125; public int height(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = height(root.left); int right = height(root.right); if(Math.abs(left - right) &gt; 1)&#123; isBalanced = false; &#125; return Math.max(left, right) + 1; &#125;&#125; 68.1 二叉查找树中两个节点的最低公共祖先思路：公共父节点的值应该：p.val &lt;= root.val &lt;= q.val: 123456789public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return root; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root;&#125; 68.2 普通二叉树中两个节点的最低公共祖先思路：采用分治思想。 12345678910111213141516171819class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root == p || root == q)&#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null &amp;&amp; right != null)&#123; return root; &#125; if(left == null)&#123; return right; &#125; return left; &#125;&#125; 字符串相关：58.1 翻转单词顺序列先旋转每个单词，再旋转整个字符串。 12345678910111213141516171819202122232425public String ReverseSentence(String str) &#123; int n = str.length(); char[] chars = str.toCharArray(); int i = 0, j = 0; while (j &lt;= n) &#123; if (j == n || chars[j] == ' ') &#123; reverse(chars, i, j - 1); i = j + 1; &#125; j++; &#125; reverse(chars, 0, n - 1); return new String(chars);&#125;private void reverse(char[] c, int i, int j) &#123; while (i &lt; j) swap(c, i++, j--);&#125;private void swap(char[] c, int i, int j) &#123; char t = c[i]; c[i] = c[j]; c[j] = t;&#125; 58. 2 左旋转字符串12345678910111213141516171819public String LeftRotateString(String str,int n) &#123; if(n &gt; str.length())&#123; return \"\"; &#125; char[] chars = str.toCharArray(); reverse(chars, 0, n - 1); reverse(chars, n, str.length() - 1); reverse(chars, 0, str.length() - 1); return new String(chars); &#125; private void reverse(char[] chars, int i, int j)&#123; while(i &lt; j)&#123; char tmp = chars[i]; chars[i] = chars[j]; chars[j] = tmp; i++; j--; &#125; &#125; 67. 把字符串转化为整数先判断正负，用boolean变量记录，然后遍历字符串，在遍历字符串的过程中进行两个判断： 第一位是否是符号位。 字符是否为数字。 123456789101112131415public int StrToInt(String str) &#123; if (str == null || str.length() == 0) return 0; boolean isNegative = str.charAt(0) == '-'; int ret = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if (i == 0 &amp;&amp; (c == '+' || c == '-')) /* 符号判定 */ continue; if (c &lt; '0' || c &gt; '9') /* 非法输入 */ return 0; ret = ret * 10 + (c - '0'); &#125; return isNegative ? -ret : ret;&#125; 其他##3. 数组中重复的数字 将值为i的元素调整到第i个位置上进行求解。 1234567891011121314151617181920public boolean duplicate(int[] nums, int length, int[] duplication) &#123; if (nums == null || length &lt;= 0) return false; for (int i = 0; i &lt; length; i++) &#123; while (nums[i] != i) &#123; if (nums[i] == nums[nums[i]]) &#123; duplication[0] = nums[i]; return true; &#125; swap(nums, i, nums[i]); &#125; &#125; return false;&#125;private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t;&#125; 4. 二维数组中的查找1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array == null || array.length == 0 || array[0] == null || array[0].length == 0)&#123; return false; &#125; int r = array.length - 1; int c = 0; while(r &gt;= 0 &amp;&amp; c &lt; array[0].length)&#123; if(array[r][c] == target)&#123; return true; &#125;else if(array[r][c] &lt; target)&#123; c++; &#125;else&#123; r--; &#125; &#125; return false; &#125;&#125;int p1 = str.length() - 1; for(int i = 0; i &lt;= p1; i++)&#123; if(str.charAt(i) == ' ')&#123; str.append(\" \"); &#125; &#125; int p2 = str.length() - 1; while(p1 &gt;= 0 &amp;&amp; p2 &gt; p1)&#123; char c = str.charAt(p1--); if(c == ' ')&#123; str.setCharAt(p2--, '0'); str.setCharAt(p2--, '2'); str.setCharAt(p2--, '%'); &#125;else&#123; str.setCharAt(p2--, c); &#125; &#125; return str.toString(); &#125; 61. 扑克牌顺子当数值为0时，可以代替任何数字，判断是否能组成顺子。 123456789101112131415161718192021public boolean isContinuous(int [] numbers) &#123; if(numbers == null || numbers.length &lt; 5)&#123; return false; &#125; int count = 0; Arrays.sort(numbers); for(int i = 0; i &lt; numbers.length; i++)&#123; if(numbers[i] == 0)&#123; count++; &#125; &#125; for(int i = count; i &lt; numbers.length - 1; i++)&#123; if(numbers[i] == numbers[i + 1])&#123; return false; &#125; if(numbers[i + 1] - numbers[i] &gt; 1)&#123; count = count - (numbers[i + 1] - numbers[i] - 1); &#125; &#125; return count &gt;= 0; &#125; 62. 圆圈中最后剩下的数约瑟夫环，长度为n的解可以看成长度为n-1的解再加上报数的长度m。因为是圆圈，所以最后需要对取余。 1234567public int LastRemaining_Solution(int n, int m) &#123; if (n == 0) /* 特殊输入的处理 */ return -1; if (n == 1) /* 递归返回条件 */ return 0; return (LastRemaining_Solution(n - 1, m) + m) % n;&#125; 66. 构建数组乘积从左到右和从右到左分别累乘。 12345678910111213public int[] multiply(int[] A) &#123; int len = A.length; int[] B = new int[len]; for(int i = 0, product = 1; i &lt; len; i++)&#123; B[i] = product; product *= A[i]; &#125; for(int i = len - 1, product = 1; i &gt;= 0; i--)&#123; B[i] *= product; product *= A[i]; &#125; return B; &#125; 位运算56. 数组中只出现一次的数字思路：相同的数字异或操作后结果为0，将数组中的所有元素进行异或操作，得到只出现一次的两个数字异或操作的值。运用diff &amp;= diff求出最低的1位 1234567891011121314public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int diff = 0; for(int i = 0; i &lt; array.length; i++)&#123; diff ^= array[i]; &#125; diff &amp;= -diff; for(int i = 0; i &lt; array.length; i++)&#123; if((array[i] &amp; diff) == 0)&#123; num1[0] ^= array[i]; &#125;else&#123; num2[0] ^= array[i]; &#125; &#125; &#125; 64. 求 1+2+3+…+n运用递归，逻辑与的短路特性作为递归的出口，&amp;&amp;后是递归运算的主体。 12345public int Sum_Solution(int n) &#123; int sum = n; boolean isValid = (n &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0; return sum;&#125; 65. 不用加减乘除做加法采用位运算，num1 ^ num2代表相加结果，(num1 &amp; num2) &lt;&lt; 1代表进位，当进位为0时计算完成。 123456public int Add(int num1,int num2) &#123; if(num2 == 0)&#123; return num1; &#125; return Add(num1 ^ num2, (num1 &amp; num2) &lt;&lt; 1); &#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"MySQL 主从复制","slug":"MySQL-主从复制","date":"2020-06-05T04:24:35.000Z","updated":"2020-06-21T03:13:11.000Z","comments":true,"path":"2020/06/04/MySQL-主从复制/","link":"","permalink":"http://yoursite.com/2020/06/04/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"MySQL主从复制过程： 当从节点连接主节点时，主节点会创建一个log dump线程，用于发送bin-log的内容。（在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，锁会被释放）。 从节点执行”start slave”命令之后，从节点会创建一个I/O线程用来连接主节点，请求主节点中更新的bin-log。从节点I/O线程接收到主节点线程发来的更新后，保存在本地relay-log中。 从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，保证主从数据的一致性。 Mysql主从复制的用途： 读写分离，提高数据库的并发能力。 实时备灾，用于故障切换。 binlog记录格式： 基于SQL语句的复制：将修改数据的sql语句存储到binlog中。 基于行的复制：将SQL语句分解为基于行更改的语句并记录在binlog中，只记录哪条数据被修改了，修改成什么样。 混合方式：两种方式都有。 复制的异步，半同步，同步模式区别： 异步模式：事务首先在主库上提交，然后再复制给从库上应用。 半同步模式(Semisynchronous Replication)：保证事务已经至少传递给一个备库再进行提交。 全同步模式：保证事务在主库和从库全部执行完并提交。 读写分离会出现的问题：在从库上会读到过期状态的结果，也就是“过期读”。 解决方案：是对于必须要拿到最新结果的请求，强制将其发到主库上。还可以采用sleep方案，主库更新后，读从库之前先sleep一下。 MySQL主从复制存在的问题 主机宕机后，数据可能丢失。解决方案采用半同步复制来解决。 从库只有一个sql 线程，复制可能延时。解决方案采用并行复制。","categories":[],"tags":[]},{"title":"sql 指令","slug":"sql-指令","date":"2020-06-05T01:49:24.000Z","updated":"2020-06-05T02:14:28.000Z","comments":true,"path":"2020/06/04/sql-指令/","link":"","permalink":"http://yoursite.com/2020/06/04/sql-%E6%8C%87%E4%BB%A4/","excerpt":"","text":"#链接 INNER JOIN：返回两张表中互相关联的记录。 LEFT JOIN：返回左表中的所有记录和右边相关联的记录。 RIGHT JOIN：返回右表中所有记录和左表中相关联的记录。 OUTER JOIN：返回左右表中的所有记录，并把左右表中相关联的记录进行连接。 分组GROUP BY：对列中相同的元素进行聚合。 HAVING：对分组后的数据进行筛选。 聚合函数： MAX() MIN() AVG() COUNT() SUM()","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"覆盖索引和回表查询","slug":"覆盖索引和回表查询","date":"2020-06-04T18:19:42.000Z","updated":"2020-06-18T05:51:24.000Z","comments":true,"path":"2020/06/04/覆盖索引和回表查询/","link":"","permalink":"http://yoursite.com/2020/06/04/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"回表查询：通过辅助索引查询到符合查询条件的记录的主键值，再到聚簇索引中通过主键来查询，叫做回表查询。 覆盖索引的概念：索引包含所查询的字段，称之为覆盖索引，避免了回表查询。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"database-lock","slug":"database-lock","date":"2020-05-31T22:23:49.000Z","updated":"2020-06-01T17:15:23.000Z","comments":true,"path":"2020/05/31/database-lock/","link":"","permalink":"http://yoursite.com/2020/05/31/database-lock/","excerpt":"","text":"锁机制三种并发控制机制：乐观锁，悲观锁和MVCC多版本并发控制机制。 乐观锁：在访问数据之前，默认不会有其它事务对数据进行修改，所以先访问数据，但在更新的时候会判断在此期间其它事务有没有修改数据。 悲观锁：按照锁的粒度把数据库锁分为表级锁和行级锁。 表级锁：对当前操作的整张表加锁，实现简单，加锁快，不会出现死锁，但是并发性低。 行级锁：只对当前操作的行加锁。可以减小冲突，提高并发性，但是加锁的开销大，容易出现死锁。 *Record Lock: *记录锁锁在索引上。 *Gap Lock: *对索引项之间的间隙加锁，锁定记录的范围，不包含索引项本身。其它事务不能在锁范围内插入数据，避免了幻影行问题。 Next-key lock:锁定索引项本身和索引范围。是记录锁和间隙锁的组合。可解决幻读问题。 根据是否独占，锁又可以分为共享锁和排他锁： 共享锁（share Lock）：又被称为读锁。其他用户可以并发读取数据，但不可以获取数据上的排他锁。 排它锁（exclusive lock）：又称写锁。若事务对数据加了排他锁，则其它事务不可以对该数据加任何类型的锁。 意向锁： 表级锁和行级锁之间存在冲突，当一个事务想给表加排他锁时，就要检测表中的每一行是否有加锁，这样一行一行的去检测是非常耗时的。所以引入了意向共享锁和意向排他锁。 意向共享锁：当事务要给数据行加共享锁时，必须先获得该表的意向共享锁。 意向排他锁：当事务要给数据行加排他锁时，必须先获得该表的意向排他锁。 当事务发现表上有意向共享锁时，说明表中的某些行被共享行锁锁住了，因此事务申请的表排他锁会被阻塞。 MVCC指Mysql在InnoDB引擎下两种隔离级别的事务（可提交读和可重复读）对于select操作访问版本链中记录的过程，这样可以使读写操作并发进行，提高系统并发性。 版本链：在InnoDB引擎表中，索引记录存储着两个必要的隐藏列，trx_id和roll_pointer指针。每次对索引记录进行修改时，都会把对应的事物id赋值给隐藏列，并把老版本写入undo日志中，并用roll_pointer指向老版本，形成版本链。 ReadView：存储了当前系统中未提交的事务，并且存储了事务id的最大值和最小值。 当进行select操作时： 如果当前访问记录的事务id小于ReadView中的最小值，则该版本的记录对当前事务是可见的。 如果当前访问记录的事务id大于ReadView中的最大值，则该版本的记录对当前事务是不可见的，应该根据回滚指针往下查找。 如果当前访问记录的事务id在范围之内，则要判断一下该id是否存在于列表中，如果存在则此版本的记录不可见，如果不存在，则可见。 读已提交和可重复读的区别就是创建ReadView的时机不同，读已提交是每次select操作前都生成ReadView，而可重复读是在第一次selcet之前生成，后续select操作继续使用第一次生成的。","categories":[],"tags":[]},{"title":"InnoDB vs Myisam","slug":"InnoDB-vs-Myisam","date":"2020-05-31T18:03:54.000Z","updated":"2020-05-31T22:23:33.000Z","comments":true,"path":"2020/05/31/InnoDB-vs-Myisam/","link":"","permalink":"http://yoursite.com/2020/05/31/InnoDB-vs-Myisam/","excerpt":"","text":"Myisam和Innodb的区别 MyISAM不支持事务，而Innodb支持事务。 MyISAM是表级锁，而Innodb是行级锁。 MyISAM不支持外键，而Innodb支持外键。 MyISAM缓存有表的行数，Innodb没有。 MyISAM是非聚集索引，Innodb是聚集索引。 总结：**MyISAM适合：1. 做很多count。2. 读密集。 3. 不要求事务。 ​ InnoDB适合：1. 要求事务。 2. 写密集。 3. 高并发。","categories":[],"tags":[]},{"title":"Spring框架","slug":"spring","date":"2020-05-25T04:43:52.000Z","updated":"2020-06-19T04:17:03.000Z","comments":true,"path":"2020/05/24/spring/","link":"","permalink":"http://yoursite.com/2020/05/24/spring/","excerpt":"","text":"Spring IOC核心容器的两个接口引发出的问题 ApplicationContext： 在构建核心容器时，创建对象采用的是立即加载的方式。适用单例对象。 BeanFactory： 在构建核心容器时，创建对象是采用延迟加载的方式。用的时候再创建对象。适用多例对象。 ##Spring对bean的管理细节 创建bean的三种方式： 使用默认构造函数创建。在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器） 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器） Bean的作用范围： bean标签的scope属性： ​ 作用：用于指定bean的作用范围。 ​ 取值： ​ singleton（单例）， ​ prototype（多例）， ​ request（作用于web应用的请求范围）， ​ session（作用于web应用的会话范围）， ​ global-session（作用于集群环境的全局会话范围，当不是集群环境时，它就是session） Bean对象的生命周期： 单例对象： ​ 出生：当容器创建时对象出生。 ​ 活着：只要容器还在，对象一直活着。 ​ 死亡：容器销毁，对象死亡。 ​ 总结：单例对象的生命周期和容器相同。 ​ 多例对象： ​ 出生：当我们使用对象时spring框架为我们创建。 ​ 活着：对象在使用过程中就一直活着。 ​ 死亡：当对象长时间不用且没有别的引用时，有Java垃圾回收器回收。 Spring的依赖注入定义：依赖关系的管理都交给spring来维护。在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明。 依赖关系的维护我们叫做依赖注入。 能注入的数据类型有三类： 基本类型和String 其他bean类型（在配置文件中或者注解配置过的bean） 复杂类型／集合类型 注入的方式有三种 使用构造函数提供。 使用的标签：constructor-arg 标签出现的位置：bean标签的内部 标签中的属性： ​ type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型。 ​ index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引位置是从0开始。 ​ name：用于指定给构造函数中指定名称的参数赋值（常用） ​ value：用于提供基本类型和String类型的数据。 ​ ref：用于指定其他bean类型数据。指的就是在spring核心容器中出现过的bean对象。 ​ 优势： ​ 在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 劣势： ​ 改变了bean对象实例化的方式，使我们再创建对象时，如果用不到这些数据，也必须提供。 使用set方法提供。 涉及的标签：property 出现的位置：bean标签的内部 标签的属性： ​ name：用于指定注入时所调用的set方法名称。 ​ value：用于提供基本类型和String数据类型。 ​ ref：用于指定其他的bean类型数据。它指的就是在Spring IOC核心容器中出现过的bean对象。 ​ 优势： ​ 创建对象时没有明确的限制，可以直接使用默认构造函数。 弊端： ​ 如果有某个成员必须有值，则获取对象时有可能set方法没有执行。 复杂类型的注入： 用于给list结构集合注入的标签：list，set，array 用于给Map结构集合注入的标签：map，props 结构相同，标签可以互换。 Spring注解 用于创建对象： @component： ​ 作用：用于把当前对象存入spring容器中 ​ 属性：value：用于指定bean的id。当我们不写时，他的默认值是当前类名，且首字母改小写。 @Controller:一般用在表现层。 @Service:一本用在业务层。 @Repository:一般用在持久层。 以上三个注解它们的作用和属性与Component是一模一样的，他们三个是spring框架为我们提供明确的三层使用的注释，使我们的三层对象更加清晰。 用于注入数据： @Autowired： ​ 作用：自动按照类型注入。只要容器中有唯一一个bean对象类型和要注入的变量类型匹配，就可以注入成功。 ​ 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 ​ 如果ioc容器中有多个类型匹配时，要注入的变量名称要和bean对象的key保持一致。 ​ 出现位置：可以是变量上，也可以是方法上。 ​ 细节： ​ 在使用注解注入时，set方法就不是必须的了。 @Qualifer： 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用(要和autowired组合在一起)。但在给方法参数注入时可以。 属性：用于指定注入bean的id。 @Resourse： 作用：直接按照bean的id注入，它可以独立使用。 属性：name用于指定bean的id。 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML实现。 @Value 作用：用于注入基本类型和String类型的数据。 属性：value用于指定数据的值。它可以使用spring中的SpEL（也就是spring的el表达式）SpEL的写法，${表达式} @configuration： 该类是一个配置类，它的作用和bean.xml是一样的 作用：指定当前类是一个配置类 @import： ​ 作用：用于导入其他的配置类。 ​ 属性： ​ value：用于指定其他配置类的字节码。 ​ 当我们使用Import的注解之后，有Import注解的类是父配置类，而导入的都是子配置类。 @ PropertySource() ​ 作用：用于指定properties文件的位置. ​ 属性： ​ value：指定文件的名称和路径。 ​ 关键字：classpath：表示类路径下。 @ComponentScan： 作用：用于通过注解指定spring在创建容器时要扫描的包。 属性： ​ value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。 我们使用此注解就等同于在xml中配置了： @Bean 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中 属性： ​ name：用于指定bean的id。当不写时，默认值是当前方法名称。 细节： 当我们使用注解配置方法时，如果方法有参数，spring框架回去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。 用于改变作用范围 @scope： 作用：用于指定bean的作用范围。 属性：value。指定范围的取值。常用取值：singleton，prototype。 和生命周期相关： @ PreDestroy 作用：用于指定销毁方法。 @PostConstruct 作用：用于指定初始化方法。 Spring AOP术语： Spring事务控制： Spring动态代理：特点：字节码随用随创建，随用随加载。 作用：不修改源码的基础上对方法增强。 分类： ​ 基于接口的动态代理。 ​ 基于子类的动态代理。 基于接口的动态代理： ​ 涉及的类：Proxy。 ​ 提供者：JDK官方。 如何创建代理对象： ​ 使用proxy类中的newProxyInstance方法。 创建代理对象的要求： ​ 被代理类最少实现一个接口，如果没有则不能使用 newProxyInstance方法的参数： ​ ClassLoader:类加载器，用于加载代理对象字节码的，和被代理对象使用相同的类加载器，固定写法。 ​ Class[]:它是用于让代理对象和被代理对象有相同的方法。固定写法。 ​ InvocationHandler: 用于提供增强的代码。它是让我们写如何代理。我们一般都是写一个该接口的实现类，通 常情况下都是匿名内部类，但不是必须的。 此接口的实现类都是谁用谁写。 基于子类的动态代理： ​ 涉及的类：Enhancer。 ​ 提供者：第三方cglib库。 如何创建代理对象： ​ 使用Enhancer类中的create方法 创建代理对象的要求： ​ 被代理类不能是最终类。 create方法的参数： ​ Class：字节码。 ​ 它是用于指定被代理对象的字节码。 ​ Callback：用于提供增强的代码。 ​ 我们一般写的都是该接口的子接口实现类：MethodInterceptor。","categories":[],"tags":[]},{"title":"Java锁机制","slug":"Java-Lock-1","date":"2020-05-21T19:08:25.000Z","updated":"2020-05-23T04:48:00.000Z","comments":true,"path":"2020/05/21/Java-Lock-1/","link":"","permalink":"http://yoursite.com/2020/05/21/Java-Lock-1/","excerpt":"","text":"乐观锁每次访问数据都认为其他线程不会修改数据，所以直接访问数据，更新的时候再判断在此期间其他线程是否修改数据。 实现： CAS机制：无锁算法。需要读写的内存值V和旧的期望值A相同时，更新为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。 版本号机制：为数据添加一个version字段，表示修改次数，在读取数据的同时读取version字段，在提交更新时，若刚才读取的version值和当前数据的version字段相等时才提交更新，否则重新尝试，直到成功。 乐观锁的缺点： 1. ABA问题： 变量初次读取和准备赋值时数值相等不代表该变量在此期间没被更改过，有可能被改为其他值又改了回来。可以用AtomicStampedReference类的compareAndSet方法，首先检查当前引用是否等于预期引用，当前标志是否等于预期标志，如果全部相等，再以原子方式将该引用和该标志的值设置为给定的更新值。 2. 循环时间长，开销大 自旋CAS如果一直不成功，开销大。 3. 无法用于共享变量 只对单变量有用，无法适用于共享变量。 CAS如何保证原子操作： CAS是通过硬件命令保证了原子性。 悲观锁定义：每次访问数据的时候都认为其他线程会修改数据。所以先获得锁，再访问数据。 实现：synchronized和ReentrantLock。 synchronized：####用法： 修饰实例方法：给当前实例对象加锁。 修饰静态方法：给当前类加锁。 修饰代码块：指定加锁对象，如果给.class结尾则是给类加锁，否则是给对象加锁。 底层实现： 无论是同步代码块还是同步方法，都是基于进入和退出Monitor对象实现的。Monitor对象存在于每个对象的对象头中。 同步代码块是根据monitorenter和monitorexit指令实现的。 同步方法是通过设置方法的ACC_SYNCHRONIZED访问标志。 公平锁和非公平锁公平锁：线程依次排队获取锁。 非公平锁：线程不管是不是队头都能获取锁。 效率：公平锁要维护一个队列，后来的线程要想获取锁，即使锁空闲，也要先检查有没有其他线程在等待获取锁，如果有，自己就要挂起，加到队列后面，然后唤醒队列最前面的线程。这种情况下相比非公平锁多了一次挂起和唤醒。非公平锁减少了线程被刮起的几率，所以效率较高。 锁优化###自旋锁 原理：如果持有锁的线程能在很短时间内释放锁，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要做自旋操作，等一等，等待持有锁的线程释放锁后即可立即获得锁。这样就避免了线程在内核态和用户态之间切换进入阻塞状态，提高了效率。 改善：1.6引入自适应自旋锁，自旋时间由上一次同一个锁的自旋时间以及锁的拥有者的状态来决定。 锁消除锁消除是编译级别的事情，在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。 锁粗化虚拟机探测到一系列操作都对同一个对象加锁解锁，就将加锁的范围粗化到整个操作系列的外部。 偏向锁使用场景：大多数情况下虽然加了锁，但是没有竞争发生，甚至同一个线程反复获得这个锁。 类比例子：一个仓库管理员管着钥匙，然而每一次都是老王去借，仓库管理员于是就认识了老王，直接和他说，“行，你直接拿就是不用填表格了我记得你”。 原理：当一个线程访问同步代码块并获取锁时，会在对象头中的Mark Word里存储锁偏向的线程ID，并把偏向锁标志为写成1。在线程进入和退出同步代码块时不需要通过CAS操作来加锁减锁，只需要在置换线程ID时候执行一次CAS原子操作即可。当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，首先暂停拥有偏向锁的线程，判断该对象是否处于处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为01）或者轻量级锁（标志位为“00”）的状态。 轻量级锁当锁是偏向锁的时候，被另外的线程所访问，偏向锁，就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。 加锁过程：JVM在当前线程的栈帧中创建用于存储锁记录的空间，叫做LockRecord，然后把Mark Word拷贝到LockRecord中，同时生成一个叫owener的指针指向那个加锁的对象。同时，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向那个Lock Record的指针。如果更新成功了，那么该线程就拥有了该对象的锁。如果更新失败，JVM会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有个这个对象的锁，可以直接进入同步块继续执行，否则说明多个线程竞争锁，升级为重量级锁。 重量级锁升级为重量级锁时，锁标志的值为“10”，此时Mark Word中存储着指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。","categories":[],"tags":[]},{"title":"Thread Local","slug":"Thread-Local","date":"2020-05-17T02:36:22.000Z","updated":"2020-05-17T03:40:30.000Z","comments":true,"path":"2020/05/16/Thread-Local/","link":"","permalink":"http://yoursite.com/2020/05/16/Thread-Local/","excerpt":"","text":"ThreadLocal##定义： ThreadLocal：让线程访问某个变量时拥有自己的线程局部变量，避免了线程间的竞争问题。 ##原理： 每个线程都有一个ThreadLocalMap，存储以ThreadLocal为key的键值对。 内存泄漏ThreadLocalMap中的key是ThreadLocal的弱引用，可以被回收，value是强引用，不可以被回收。为了避免ThreadLocal为null而value不为null的情况，在调用ThreadLocalMap中的get和set方法时，会对key进行判断，如果为null，则把value也设置为null。也可以调用ThreadLocal的remove方法，清理key为null的value。","categories":[],"tags":[]},{"title":"Linux commnad","slug":"Linux-command","date":"2020-05-15T21:35:10.000Z","updated":"2020-05-15T21:35:58.000Z","comments":true,"path":"2020/05/15/Linux-command/","link":"","permalink":"http://yoursite.com/2020/05/15/Linux-command/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"database transaction isolation level","slug":"database-transaction-isolation-level","date":"2020-05-10T18:00:08.000Z","updated":"2020-05-10T18:03:03.000Z","comments":true,"path":"2020/05/10/database-transaction-isolation-level/","link":"","permalink":"http://yoursite.com/2020/05/10/database-transaction-isolation-level/","excerpt":"","text":"隔离级别未提交读事务中的修改，即使没有提交，对其他事务也是可见的。 提交读一个事务只能读取已经提交的事务所做的修改。 可重复读保证在同一个事务中多次读取同一个数据的结果是一样的。 可串行化强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。","categories":[],"tags":[]},{"title":"MySQL","slug":"Database-ACID-0","date":"2020-05-10T04:58:39.000Z","updated":"2020-06-21T05:19:14.000Z","comments":true,"path":"2020/05/09/Database-ACID-0/","link":"","permalink":"http://yoursite.com/2020/05/09/Database-ACID-0/","excerpt":"","text":"事务事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 ACID1. 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部回滚失败。 2. 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。 3. 隔离性（Isolation）一个事务所做的修改在最终提交之前，对其他事务是不可见的。 4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中，即使系统发生崩溃，事务的执行结果也不能丢失。 并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 丢失修改T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。 读脏数据T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。 不可重复读T2读取了一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻影读T1读取某个范围内的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。 隔离级别未提交读事务中的修改，即使没有提交，对其他事务也是可见的。 提交读一个事务只能读取已经提交的事务所做的修改。 可重复读保证在同一个事务中多次读取同一个数据的结果是一样的。 可串行化强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 数据库的三范式第一范式第一范式的目标是确保每列的原子性：如果每列都是不可再分的最小数据单元，则满足第一范式（1NF） 第二范式首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。所谓部分依赖含义是非主键列必须完全依赖于主键，而不能依赖主键的一部分。 第三范式满足第二范式，消除传递依赖，即任何非主属性不依赖于其他非主属性。 锁机制三种并发控制机制：乐观锁，悲观锁和MVCC多版本并发控制机制。 乐观锁：在访问数据之前，默认不会有其它事务对数据进行修改，所以先访问数据，但在更新的时候会判断在此期间其它事务有没有修改数据。 悲观锁：按照锁的粒度把数据库锁分为表级锁和行级锁。 表级锁：对当前操作的整张表加锁，实现简单，加锁快，不会出现死锁，但是并发性低。 行级锁：只对当前操作的行加锁。可以减小冲突，提高并发性，但是加锁的开销大，容易出现死锁。 *Record Lock: *记录锁锁在索引上。 *Gap Lock: *对索引项之间的间隙加锁，锁定记录的范围，不包含索引项本身。其它事务不能在锁范围内插入数据，避免了幻影行问题。 Next-key lock:锁定索引项本身和索引范围。是记录锁和间隙锁的组合。可解决幻读问题。 根据是否独占，锁又可以分为共享锁和排他锁： 共享锁（share Lock）：又被称为读锁。其他用户可以并发读取数据，但不可以获取数据上的排他锁。 排它锁（exclusive lock）：又称写锁。若事务对数据加了排他锁，则其它事务不可以对该数据加任何类型的锁。 意向锁： 表级锁和行级锁之间存在冲突，当一个事务想给表加排他锁时，就要检测表中的每一行是否有加锁，这样一行一行的去检测是非常耗时的。所以引入了意向共享锁和意向排他锁。 意向共享锁：当事务要给数据行加共享锁时，必须先获得该表的意向共享锁。 意向排他锁：当事务要给数据行加排他锁时，必须先获得该表的意向排他锁。 当事务发现表上有意向共享锁时，说明表中的某些行被共享行锁锁住了，因此事务申请的表排他锁会被阻塞。 MVCC指Mysql在InnoDB引擎下两种隔离级别的事务（可提交读和可重复读）对于select操作访问版本链中记录的过程，这样可以使读写操作并发进行，提高系统并发性。 版本链：在InnoDB引擎表中，索引记录存储着两个必要的隐藏列，trx_id和roll_pointer指针。每次对索引记录进行修改时，都会把对应的事物id赋值给隐藏列，并把老版本写入undo日志中，并用roll_pointer指向老版本，形成版本链。一个数据可能存在多个版本，每个版本有自己的事务id，用roller_pointer连接形成版本链。 ReadView：存储了当前系统中未提交的事务，并且存储了事务id的最大值和最小值。 当进行select操作时： 如果当前访问记录的事务id小于ReadView中的最小值，则该版本的记录对当前事务是可见的。 如果当前访问记录的事务id大于ReadView中的最大值，则该版本的记录对当前事务是不可见的，应该根据回滚指针往下查找。 如果当前访问记录的事务id在范围之内，则要判断一下该id是否存在于列表中，如果存在则此版本的记录不可见，如果不存在，则可见。 读已提交和可重复读的区别就是创建ReadView的时机不同，读已提交是每次select操作前都生成ReadView，而可重复读是在第一次selcet之前生成，后续select操作继续使用第一次生成的。 Mysql索引类型与应用场景1. 索引的数据结构1. B+树为什么使用B+树：检索一次最多需要访问h个节点，数据库系统的设计者利用磁盘预读的原理，将一个节点的大小设计成等于一个页，每次新建节点时都申请一个页的空间，保证一个节点物理上存储到一个页里，加之计算机存储分配都是按页对齐的，这样每个节点一次I／O就可以完全载入，B+树在实际应用中的出度非常大，所以高度很小。综上所述，B+树作为索引结构效率非常高。 2. Hash索引（只有Memory存储引擎支持） Hash索引使用Hash算法，把键值转换成Hashcode，存放在索引中，同时哈希表中保存指向每个数据的指针。在检索时一次定位。 Hash 索引只支持等值查询，仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用例如”&gt;”, “LIKE”操作符的范围查询。在没有大量键值重复的前提下，效率有明显的优势。 hash索引无法利用索引进行排序。 不支持多列索引中的最左前缀原则，无法进行部分匹配查找，因为哈希索引使用索引列的全部内容计算哈希值。不过B+树索引因为支持最左前缀原则，支持部分匹配查找。 在有大量重复键值的情况下，哈希冲突很多，维护索引操作的代价也很高，效率变低。 总结：如果是等职查询，哈希索引有绝对优势， 2. 索引的类型 普通索引：最基本的索引，没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值（注意与主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 全文索引（FULLTEXT）：全文索引仅可用于MyISAM表，他们可以从CHAR，VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或者是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更快。 单列索引、多列索引：多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）：对多个列建立索引，遵循最左前缀原则：最左优先，只从最左边的开始组合。 参考文献深入理解索引底层实现 Myisam和Innodb的区别 MyISAM不支持事务，而Innodb支持事务。 MyISAM是表级锁，而Innodb是行级锁。 MyISAM不支持外键，而Innodb支持外键。 MyISAM缓存有表的行数，Innodb没有。 MyISAM是非聚集索引，Innodb是聚集索引。 总结：MyISAM适合：1. 做很多count。2. 读密集。 3. 不要求事务。 ​ InnoDB适合：1. 要求事务。 2. 写密集。 3. 高并发。 聚集索引和非聚集索引的区别 聚集索引：**数据文件** 本身 就是索引文件。B+树叶子节点的data域完整保存了数据记录。索引的key是数据表的主键。其余的索引为辅助索引，辅助索引叶子节点data域存放的是对应的主键的值，查找时先在辅助索引中获取主键值，然后在聚集索引中获取完整的数据记录。所以在设计表时不建议用过长的字段作为主键。聚集索引用于InnoDB存储引擎中。 非聚簇索引：B+树叶子节点data域存放的是数据记录的地址。MyISAM存储引擎所使用，索引文件和数据文件分离。 回表查询：通过辅助索引查询到符合查询条件的记录的主键值，再到聚簇索引中通过主键来查询，叫做回表查询。 覆盖索引的概念： 索引 包含所查询的字段，称之为覆盖索引，避免了回表查询。 explain指令explain命令输出的结果有10列： id：值越大，优先级越高，越先被执行。 select_type： SIMPLE：不包含UNION或subQuery。 PRIMARY：查询包含UNION或子查询，则最外层的查询为PRIMARY。 SUBQUERY：子查询中的第一个select语句 DERIVED：包含在from子句中的子查询。 table：显示正在访问哪个表。 type：表示MySQL在表中查找所用的方式。有ALL，index，range，ref，eq_ref, const, system, null从左到右性能依次变好。 possible_keys：可能用那些索引来查找。 key：实际决定使用哪些索引。 key_len：索引实际使用的字节数。 ref：表示那些字段或者常量用来和索引配合从表中查询记录。 rows：估计要找到记录所需读取的行数。 extra：其他信息，比如Using index，使用覆盖索引，用索引就可以找到数据信息，不需要进行回表操作。 如何对一条SQL语句进行调优 尽量选择字段长度较小的列 将where及order by语句中涉及比较频繁的列建立索引 select子句中避免使用“*”，应指定具体的列名。 当只需要一行数据的时候使用limit 1 避免在where子句中使用 ！=或者&lt;&gt;操作符，否则引擎将放弃索引使用全表扫描 in和not in也要慎用，否则会导致全表扫描，对于连续的数值，可以用between代替in 如果查询的两个表大小相当，用in和exists和in差别不大，当子查询表大时，可以用exists，子查询表小的时候用in。not in和not exists相比时，无论哪个表大，用not exists都比not in快，此外not in可能会产生逻辑错误，子查询所返回的记录中不可以有空值。 避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 保证表单数据不超过200w，适时分割表 针对查询较慢的语句，可以使用explain来分析该语句具体的执行情况 避免查询时判断null，否则可能会导致全表扫描，无法使用索引 避免使用%前缀的like查询，否则可能导致全表扫描，可以考虑使用全文索引，全文索引使用分词器将字段分割成一个个token_text，并且记录这些token_text来自表里的那些行，把这些信息记录到索引中，用空间换时间。 能用union all的时候就不用union，union去重合排序的过程要耗费更多的CPU资源。当然，union all的前提条件是两个结果集没有重复数据。 联合索引如何存储：索引列全部出现在B+书中，首先按照第一列（最左前缀）进行排序，如果相等，则按照第二列进行排序，依次递推。 如何查找：先按照第一列进行查找，再按照第二列进行查找，依次递推。 存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置。范围列可以用到索引，但范围列后面的列无法用到索引。 Mysql主从复制MySQL主从复制过程： 当从节点连接主节点时，主节点会创建一个log dump线程，用于发送bin-log的内容。（在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，锁会被释放）。 从节点执行”start slave”命令之后，从节点会创建一个I/O线程用来连接主节点，请求主节点中更新的bin-log。从节点I/O线程接收到主节点线程发来的更新后，保存在本地relay-log中。 从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，保证主从数据的一致性。 Mysql主从复制的用途： 读写分离，提高数据库的并发能力。 实时备灾，用于故障切换。 binlog记录格式： 基于SQL语句的复制：将修改数据的sql语句存储到binlog中。 基于行的复制：将SQL语句分解为基于行更改的语句并记录在binlog中，只记录哪条数据被修改了，修改成什么样。 混合方式：两种方式都有。 复制的异步，半同步，同步模式区别： 异步模式：事务首先在主库上提交，然后再复制给从库上应用。 半同步模式(Semisynchronous Replication)：保证事务已经至少传递给一个备库再进行提交。 全同步模式：保证事务在主库和从库全部执行完并提交。 读写分离会出现的问题：在从库上会读到过期状态的结果，也就是“过期读”。 解决方案：是对于必须要拿到最新结果的请求，强制将其发到主库上。还可以采用sleep方案，主库更新后，读从库之前先sleep一下。 MySQL主从复制存在的问题 主机宕机后，数据可能丢失。解决方案采用半同步复制来解决。 从库只有一个sql 线程，复制可能延时。解决方案采用并行复制。 参考链接MYSQL查询SQL语句性能优化方法 浅谈sql中的in与not in,exists与not exists的区别以及性能分析","categories":[],"tags":[]},{"title":"数据库的三范式","slug":"Database-Normalization","date":"2020-05-09T16:07:54.000Z","updated":"2020-05-10T04:56:55.000Z","comments":true,"path":"2020/05/09/Database-Normalization/","link":"","permalink":"http://yoursite.com/2020/05/09/Database-Normalization/","excerpt":"","text":"数据库的三范式第一范式第一范式的目标是确保每列的原子性：如果每列都是不可再分的最小数据单元，则满足第一范式（1NF） 第二范式首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。所谓部分依赖含义是非主键列必须完全依赖于主键，而不能依赖主键的一部分。 第三范式满足第二范式，消除传递依赖，即任何非主属性不依赖于其他非主属性。","categories":[],"tags":[]},{"title":"Java Design Pattern","slug":"Java-Design-Pattern","date":"2020-05-09T04:42:52.000Z","updated":"2020-05-09T16:06:33.000Z","comments":true,"path":"2020/05/08/Java-Design-Pattern/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-Design-Pattern/","excerpt":"","text":"#Java设计模式 创建型模式：共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式。 结构性模式：适配器模式，代理模式，享元模式。 行为型模式：策略模式，观察者模式。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 为什么要用单例模式？在我们的系统中，有一些对象我们只需要一个实例，比如：线程池，缓存等。如果制造出多个实例就会导致一些问题的产生，比如：程序的行为异常，资源使用过量，或者不一致性的结果。 简单的说一下单例模式可以带来下面几个好处： 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销 由于new操作次数的减少，因为对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。 为什么不使用全局变量确保一个类只有一个实例呢？全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。 只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间。但是，如果这个对象非常消耗资源，而且程序的某次执行中一直没用，就会造成资源浪费。利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。此外，在程序中大量使用全局变量给程序的调试，维护等带来困难。 单例模式的实现 饿汉模式：指全局的单例实例在类装载时构建。 懒汉方式：指全局的单例实例在第一次被使用时构建。 参考深入理解单例模式——只有一个实例","categories":[],"tags":[]},{"title":"谈谈对面向对象的理解","slug":"object-oriented-programming","date":"2020-05-09T03:45:01.000Z","updated":"2020-05-09T04:41:30.000Z","comments":true,"path":"2020/05/08/object-oriented-programming/","link":"","permalink":"http://yoursite.com/2020/05/08/object-oriented-programming/","excerpt":"","text":"Java面向对象 继承：继承是从已有类得到继承信息创建新类的过程。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。在类中编写的方法是对实现细节的一种封装；编写一个类就是对数据和数据操作的封装。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是同样的对象引用调用同样的方法做了不同的事情。多态性分为编译时的多态性和运行时的多态性。overload实现的是编译时的多态性，override实现的是运行时的多态性。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 访问权限修饰符public, private， protected，以及默认时的区别","categories":[],"tags":[]},{"title":"Java String Class","slug":"Java-String-Class","date":"2020-05-08T23:02:11.000Z","updated":"2020-05-08T23:51:49.000Z","comments":true,"path":"2020/05/08/Java-String-Class/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-String-Class/","excerpt":"","text":"String，StringBuffer，StringBuilder的区别##可变性： String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，没有用final关键字修饰，所以这两种对象都是可变的。 线程安全性String中的对象是不可变的，可以理解为常量，线程安全。 StringBuffer对方法加了同步锁，所以是线程安全的。 StringBuilder没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变时，都会生成一个新的对象，然后将指针指向新的String对象。 StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用StringBuilder比使用StringBuffer仅能获得10%-15%左右的性能提升，但却要冒多线程不安全的风险。 总结操作少量数据：适合用String。 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder。 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。 为什么String是不可变类，有什么好处 字符串常量池的需要：字符串常量池是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假设此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。假如字符串对象允许改变，那么将导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象 允许String对象缓存HashCode：Java中String对象的哈希码被频繁地使用，比如在HashMap等容器中。字符串的不变性保证了哈希码的唯一性，不必每次都去计算新的哈希码，因此可以放心的进行缓存。 安全性：String被许多类当作参数，例如网络链接地址URL，文件路径Path，还有反射机制所需要的参数等，假设String不是固定不变的，将会引起各种安全隐患。","categories":[],"tags":[]},{"title":"Java Lock","slug":"Java-Lock","date":"2020-05-08T21:20:29.000Z","updated":"2020-05-08T23:01:57.000Z","comments":true,"path":"2020/05/08/Java-Lock/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-Lock/","excerpt":"","text":"何为悲观锁，何为乐观锁悲观锁总是假设最坏的情况，每次拿数据都认为别人会修改，所以每次在拿数据的时候都会上锁。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但在更新的时候会判断一下在此期间别人有没有去更新这个数据。 两种锁的适用场景乐观锁适用于读比较多，写比较少的情况下，省去了锁的开销，加大了整个系统的吞吐量。乐观锁适用于写比较多的情况下，一般会经常产生冲突，加锁可以提高效率。 乐观锁常见的两种实现方式 版本号机制：在数据表中加入一个version字段，表示数据被修改的次数，当数据被修改时，version值加一。当线程A要更新数据时，读取数据的同时也会读取version值，在提交更新时，当刚才读取到的version值和当前数据库中的version值相等时才提交更新，否则重试更新操作，直到更新成功。 CAS算法：当需要读写的内存值和进行比较的值相等时，CAS通过原子操作用新值更新内存中的值。 乐观锁的缺点1. ABA问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，不能说明这个变量没有被修改过，因为这段时间他有可能被改为其他值，然后又改回A。 2. 循环时间长开销大不成功的话就一直循环执行直到成功，如果长时间不成功，则会给CPU带来非常大的执行开销。","categories":[],"tags":[]},{"title":"Java Parents delegate","slug":"Java-Parents-delegate","date":"2020-05-08T16:47:41.000Z","updated":"2020-05-08T17:29:26.000Z","comments":true,"path":"2020/05/08/Java-Parents-delegate/","link":"","permalink":"http://yoursite.com/2020/05/08/Java-Parents-delegate/","excerpt":"","text":"Java类加载器主要的类加载器 启动类加载器（BootStrapClassLoader）：该ClassLoader是JVM在启动时创建的，用于加载JAVA_HOME/jre/lib下面的类库。 扩展类加载器（ExtClassLoader）：扩展类加载器会加载JAVA_HOME/jre/ext下的类库。 应用程序类加载器（AppClassLoader）：应用程序类加载器会加载java环境变量CLASSPATH所指定的路径下的类库。 自定义类加载器（CustomClassLoader）：指我们自己定义ClassLoader。 双亲委派机制 当应用程序类加载器加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器扩展类加载器来完成。 当扩展类加载器加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给启动类加载器去完成。 如果启动类加载器加载失败，则会使用扩展类加载器来尝试加载。 若扩展类加载器也加载失败，则会使用应用程序类加载器来加载。 双亲委派机制安全类加载器加载的.class文件来源很多，有的.class文件不可靠，比如可以自定义一个Integer类，里面包含了一些不安全的代码。采用双亲委派机制的话，该Integer类永远不会被调用，因为是由启动类加载器来加载默认的Integer类，而不是自定义的不安全的Integer类。 Java如何打破双亲委派自定义类加载器，继承ClassLoader覆盖loadClass方法。 LoadClass的原顺序为: findLoadedClass 委托parent加载器加载 自行加载 打破双亲委派机制就是要打乱2和3的顺序，通过类名筛选到自己要加载的类，其他的委托给parent加载器。","categories":[],"tags":[]},{"title":"Java reflection","slug":"Java-reflection","date":"2020-05-08T00:03:15.000Z","updated":"2020-05-17T02:22:29.000Z","comments":true,"path":"2020/05/07/Java-reflection/","link":"","permalink":"http://yoursite.com/2020/05/07/Java-reflection/","excerpt":"","text":"Java基础之反射反射的定义在程序运行中，动态获取Java类中成分的机制，成分包括（成员变量，成员方法，构造函数，类对象）等等。 反射的应用 反射可以让开发人员通过外部类的全路径名创建对象，并使用这些类实现一些扩展功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数，成员变量，成员方法。以帮助开发者写出正确的代码。 测试时也可以利用反射API访问类的私有成员，以保证测试代码覆盖率。 反射就是把Java类中的各种成分（包括成员变量，成员方法，构造方法，包等等信息）映射成一个个的Java对象。 如何反射获取Class对象 通过Class.forName加上路径名来获取类对象。 通过类的class属性来获取对象。 通过对象的getClass（）函数来获取对象 其中第一种方法最常见，第二种方法需要倒入类的包，第三种方法已经有Student对象，不需要再反射。 通过反射获取成员变量获取成员变量有两个API：getFields（）和getDeclaredFields（）。区别在于getDeclaredFields用于获取所有声明的字段，包括public, private, protected, defaulted, getFields仅用来获取公有字段。 获取构造方法获取构造方法同样包含了两个API：getConstructors()和getDeclaredConstructors。getConstructors用来获取共有构造方法，getDeclaredConstructors用来获取所有构造方法。 获取成员方法同样包含两个API：getMethods()和getDeclaredMethods()。getMethods()用来获取公有的成员方法，getDeclaredMethods()用来获取所有的成员方法。 访问私有成员变量和方法setAccessible(true)暴力解除限制。 强制转换类型：class.newInstance() 参考Java基础之—反射（非常重要) 详解面试中常考的 Java 反射机制","categories":[],"tags":[]},{"title":"garbage collection","slug":"garbage-collection","date":"2020-05-06T18:09:52.000Z","updated":"2020-06-15T10:41:56.000Z","comments":true,"path":"2020/05/06/garbage-collection/","link":"","permalink":"http://yoursite.com/2020/05/06/garbage-collection/","excerpt":"","text":"垃圾回收算法1. 标记-清除算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： 效率问题。 空间问题（标记清除后会产生大量不连续的碎片） 2. 复制算法为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到两一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 3. 标记-整理算法根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 4. 分代收集算法将Java堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都有大量的对象死去，所以可以选择复制算法，只要付出少量对象复制的成本就可以完成每次的垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集。 垃圾收集器1. Serial收集器用于新生代的单线程垃圾收集器，垃圾回收的时候，必须暂停其他线程的工作，采用复制算法。 只会使用一条垃圾收集线程去完成垃圾收集工作，并且在垃圾收集工作的时候必须暂停其他所有的工作线程，直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 2. ParNew收集器Serial收集器的多线程版本，采用复制算法。 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和Serial收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 3. Parallel Scavenge收集器多线程收集器，注重吞吐量，提供用户一些参数供用户找到最合适的停顿时间和最大的吞吐量。 Parallel Scavenge收集器关注点是吞吐量（高效率利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或者最大吞吐量。 新生代采用复制算法，老年代采用标记-整理算法。 4. Serial Old收集器serial的老年代版本，采用标记整理算法 Serial收集器的老年代版本。它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。 5. Parallel Old收集器Parallel Scavenge的老年代版本，多线程收集，采用标记整理算法 Parallel 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器 6. CMS收集器注重最短停顿时间，并发收集器，垃圾收集线程于用户工作线程基本同时工作。采用标记清除算法。 初始标记，并发标记，重新标记，并发清除。 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS收集器HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾回收线程与用户线程（基本上）同时工作。 CMS收集器是一种“标记-清除”算法实现的，它的运作工程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。 并发标记：可达性分析过程。同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含所有可达对象。因为用户线程可能会不断更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记：重新标记阶段是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。 并发清除：开启用户线程，同时GC线程开始对标记的区域做清扫。 从它的名字可以看出它是一款优秀的垃圾收集器，主要优点：并发收集，低停顿。但是它有下面三个明显的缺点： 低停顿时间是以牺牲吞吐量为代价，导致CPU利用率不够高； 无法处理浮动垃圾，浮动垃圾是指并发清除阶段产生的垃圾，如果预留空间不够，将临时启用serial old代替CMS； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片的产生。 G1收集器优点：低停顿，高吞吐。 建立可预测的停顿时间模型（使用户指定垃圾回收时间）；将堆分成多个大小相同的region，宏观上采用标记整理，微观上采用复制算法； 初始标记，并发标记，最终标记，筛选回收。 筛选回收是根据各个region的回收价值和停顿时间成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。 G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器以及大容量内存的机器，已极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。 此垃圾收集器不需要和别人配合，自己处理新生代和老年代。在JDK9中G1变为Server模式默认的垃圾收集器。它的发明就是为了替代CMS。 G1（Garbage-First）从整体来看是基于标记-整理算法，从局部来看是基于复制算法。相对于CMS它的优点是首先它能建立可预测的停顿时间模型，能在一个规定的时间段内制定垃圾收集的时间不超过限制的毫秒数，并且将Java堆分为多个大小相等的独立区域，它的清理区间不再是整个新生代或者老年代，而是以区域为划分，不会产生空间碎片。 G1会维护一个优先列表，根据跟踪各个region回收所能产生的空间大小和时间来标定优先级，优先回收优先级最大的region。这就等于每次的回收目标更加精确话，提高回收的效率，G1的收集步骤可分为： 初始标记 并发标记 最终标记 筛选回收 初始标记和CMS一样先标记GC Roots直接关联对象，然后并发深入标记，便利关联对象。最终标记和CMS重新标记一个概念，筛选回收就是筛选下决定回收哪个Region价值更大。 参考面试官：谈谈你对JVM垃圾收集器的了解 JVM 垃圾回收","categories":[],"tags":[]},{"title":"Java concurrent II","slug":"Java-concurrent-II","date":"2020-05-03T19:32:32.000Z","updated":"2020-06-16T22:03:41.000Z","comments":true,"path":"2020/05/03/Java-concurrent-II/","link":"","permalink":"http://yoursite.com/2020/05/03/Java-concurrent-II/","excerpt":"","text":"Java并发进阶常见面试题总结说说并发和并行的区别 并发：同一时间段内，多个任务都在执行（单位时间内不一定同时执行）。 并行：单位时间内，多个任务同时执行。 线程安全和非线程安全 线程安全：一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能正常运行，我们就称是线程安全的。 非线程安全：一个类在单线程环境下正常运行，在多线程环境下无法正常运行，这个类就是非线程安全的。 为什么要使用多线程先从总体上来说： 从计算机底层来讲：线程的切换和调度成本远远小于进程。在单核CPU时代，多线程主要是为了提高CPU和IO设备的综合利用率；在多核CPU时代，多线程主要是为了提高CPU利用率，让多个CPU核心被利用到。 从互联网发展趋势来讲，现在的系统要求高并发量，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别A.start()是启动一个新线程，进入就绪状态，start方法只能被调用一次。 run()方法，就绪状态的线程获取cpu之后调用的，线程进入运行状态，如果手动调用，相当于执行一个普通的方法。 wait()/notify()方法：线程调用wait()方法，释放对象的锁，进入该对象的等待队列，其他线程调用notify/notifyAll()方法唤醒等待队列中的线程，线程进入锁池，等待获取对象锁，获取之后进入就绪状态。 为什么wait和notify方法要放入synchronized代码块中： wait()的含义是释放对象的锁，并将线程放入该对象的等待队列，要想释放锁必须先拥有锁，所以wait()要放入 synchronized同步代码块中。 notify()方法是通知等待队列中的线程进入锁池，准备获取锁，只有当获取到该对象的琐时，才有资格通知其他线程去做好准备获取锁。 为什么wait()方法要放在while()循环中 对于从等待队列中唤醒的线程来说，被唤醒后还需要检查是否符合执行条件，如果不符合，就再次被wait。 yield()方法：Thread的静态方法，表示当前线程从运行状态转入就绪状态，不会释放任何锁。 sleep()方法：Thread的静态方法，表示当前线程从运行状态转入阻塞状态，不释放任何锁，休眠一段时间后，该线程进入就绪状态。 join()方法：假如A线程调用join()方法，则当前线程进入阻塞状态，等线程A执行完成之后，当前线程从阻塞状态进入就绪状态。 interrupt()：调用interrupt()，中断标志设置为true，当线程处于wait(), join(), sleep()等阻塞状态时，清除中断标记，抛出InterruptException异常，通过代码捕获异常，break跳出循环，线程结束。 isInterrupted()：当线程未处于阻塞状态，通过isInterrupted()方法检查中断标志位来退出循环。相比于interrupted(), 此方法不会清除标志位。 Executor的中断：shutdown()中断和shutdownNow()中断，区别是shutdown()不接受新的任务，等待线程中所有的任务完成。shutdownNow()不接受新的和未处理的，调用每个正在执行的线程的interrupt()。 中断线程池中的一个线程：使用submit方法提交线程，会返回一个future对象，调用该对象的cancel方法中断线程。 使用多线程可能带来什么问题肯能会存在：内存泄漏，上下文切换，死锁还有受限于硬件和软件的资源闲置问题。 说说线程的生命周期和状态线程有六个状态：NEW，RUNNABLE，BLOCKED，WAITING，TIME_WAITING，TERMINATED。 什么是上下文切换当前任务执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以加载这个任务的状态。 什么是死锁，如何避免死锁死锁产生的四个条件多个线程同时被阻塞，它们中的一个或多个全部都在等待某个资源被释放。 产生死锁必须具备以下四个条件： 互斥条件：该资源任意时刻只由一个线程占用。 请求于保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其它线程强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 说说sleep（）方法和wait（）方法的区别和共同点 两者的主要区别是：sleep（）方法没有释放锁，而wait方法释放了锁。 两者都可以暂停进程的执行。 Wait通常用于进程间的交互／通信，sleep（）通常用于暂停执行。 wait（）方法被调用后线程不会自动苏醒，需要别的线程调用同一个对象上的notify（）或者notify（）方法。sleep（）方法执行完成后，线程会自动苏醒。或者可以使用wait（long timeout），超时后线程会自动苏醒。 为什么我们调用start（）方法时会执行run（）方法，为什么我们不能直接调用run（）方法调用start（）方法可以启动线程并使线程进入就绪状态，而run方法只是线程的一个普通方法调用，还是在主线程里执行。 1. synchronized关键字1.1 说一说自己对于synchronized关键字的理解synshronized关键字解决的是多个线程访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程在执行。 synchronized关键字加到static静态方法和synchronized（class）代码块上都是给Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。 ###1.2 synchronized关键字的底层原理 synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块结束的位置。 syschronized修饰的方法是用ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。 1.3 谈谈synchronized和ReentrantLock的区别 两者都是可重入锁。“可重入锁”的概念是：自己可以再次获取自己的内部锁。 sysnchronized是依赖于JVM实现的，并没有直接暴露给我们。ReentrantLock是JDK层面实现的，需要lock（）和unlock（）方法配合try／finally语句块来完成。 ReentrantLock比synchronized增加了一些高级功能。主要有三点：（1）等待可中断；（2）实现公平锁（3）基于Condition实现线程选择性通知（锁可以绑定多个条件） ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。 ReentranLock可以制定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓公平锁就是先等待的线程先获得锁。 synchronized关键字与wait（）和notify／notifyAll（）方法相结合实现等待／通知机制。ReentrantLock通过Condition接口与newCondition（）方法实现等待／通知机制。具体实现方法是线程对象注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度上更加灵活。 Java内存模型可以把内存模型简化为主内存和线程本地内存。线程可以把变量从主内存读到本地缓存，然后在本地缓存中进行读写，然后将改变结果写到内存中。这就导致了线程本地内存和主内存数据不一致的情况。即可见性，volatile可以解决这个问题。 volatile关键字被volatile修饰的共享变量，具有以下两点特性： 保证了不同线程对该变量操作的内存可见性。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主内存，当其他线程需要读取该变量时，会从主存中读取新值。而普通变量则不能保证这一点。 虚拟机会使用内存屏障禁止指令重新排序保障其有序性。 底层实现：volatile修饰的变量会在汇编阶段多出一条lock前缀指令，导致当前处理器缓存的数据立刻写回到主内存中，且让其他修改该数据的处理器的缓存失效。是synchronized的轻量级实现，只能保证可见性，无法保证原子性。 3. 可重入锁和非可重入锁的区别不可重入锁：当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。 可重入锁：当前线程获取对象锁之后，该线程可以再次获取本对象上的锁，而其他线程是不可以的。可重入锁的意义在于防止死锁。 4. 线程池线程池就是通过创建一定数量的线程，让他们时刻就绪等待新任务的到达，任务执行结束之后再重新回来继续待命。 4.1 线程池的好处 降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁造成的消耗。 提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性：无限制的创建线程会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一的分配，调优和监控。 4.2 ThreadPoolExecutor构造函数重要参数分析 corePoolSize：定义了最小可以同时运行的线程数量。 maximumPoolSize：队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 keepAliveTime：当线程池中的线程数量大于corePoolSize的时候，如果这时候没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待时间超过了keepAliveTime才会被回收。 unit：KeepAliveTime参数的时间单位。 threadFactory：executor创建线程的时候会用到。 handler：饱和策略。 4.3 ThreadPoolExecutor饱和策略：如果同时运行的线程数量达到最大线程数并且队列已经被放满了任务时，ThreadPoolExecutor定义了一些策略： ThreadPoolExecutor.AbortPolicy: 抛出RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy:调用执行自己的线程运行任务。 TreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢掉。 ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。 4.4 Java中有哪些常用的线程池Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool创建一个定长线程池，可控制线程的最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。 Java中多线程怎么通信 共享变量：线程间可以通过在共享对象的变量里设置信号值来发送信号。比如线程A在一个synchronized的语句块中设置一个boolean的成员变量hasDataToProcess为true，线程B在synChronized语句块中读取hasDataToProcess，如果是true就执行代码，否则就等待。这样就实现了线程A对线程B的通知。 wait/notify()/notifyAll()机制： 一个线程可以对任何一个对象调用wait方法，这样这个线程就会变成wait状态，inactive，等待其他线程在同一个对象上调用notify（）方法，来唤醒这个线程。值得注意的是，在调用wait和notify方法之前，必须要先获得这个对象的锁。 AQS抽象的队列式的同步器，是一个构建锁和同步器的框架。 原理：如果被请求的共享资源空闲，则把当前请求线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制AQS是用CLH队列锁实现的。即将暂时获取不到锁的线程放入队列中。CLH是虚拟的双向队列，即不存在队列实例，仅存在节点与节点之间的pre与next关系。AQS将每条请求共享资源的线程封装成一个CLH锁队列的一个节点来实现锁的分配。 AQS属性：Node head, Node tail, int state(代表当前锁的状态，0代表没有被占用，大于0代表示有线程持有当前锁)，Thread 持有独占锁的线程。 等待队列中的每个线程被封装为一个Node实例（thread + waitStatus(-1 : 当前node的后继节点对应的线程需要被唤醒) + pre + next）。 waitStatus属性：默认为0，当大于0时，表示放弃等待；当等于-1时，表示当前节点的后继节点对应的线程需要被唤醒。当等于-2时，标志着线程在Condition条件上等待的线程唤醒。等于-3时，用于共享锁，标志着下一个调用acquireShared方法的线程应该被允许。 底层实现和应用 AQS使用volatile修饰的state变量表示同步状态，通过内置的CLH先进先出队列完成获取资源的线程的排队工作。AQS使用CAS原子操作实现对变量state的修改。 类别：共享锁和独占锁。 AQS提供了模版方法： 自定义同步器的步骤： 继承AbstractQueuedSynchronizer并重写指定的方法。包括（tryAcquire()/tryRelease或者tryAcquireShared()/tryReleaseShared，本质是对共享资源state的操作）。 将组合在自定义的同步器的实现中，并调用重写的模版方法。 CountDownLatch： 功能：让一个线程等待一组线程完成之后才能执行。 工作原理：CountDownLatch对象维护一个计数器count，执行一次countDown()，计数器count减1，当count减到0时，await()方法阻塞的当前线程才能运行。 CyclicBarrier： 功能：让一组线程等待至某个状态之后再全部同时执行。 原理：初始化CyclicBarrier对象，指定一起运行的线程的数量，在每个子线程中调用await()方法，参与者的数量加一，当参与者数量达到初始化的大小时，所有线程一起执行后面的动作。 CountDownLatch和CyclicBarrier区别： 功能上，CountDownLatch是让一个或多个线程等待一组线程执行完毕，CyclicBarrier是允许多个线程相互等待，直到到达某个公共屏障点。 CountDownLatch的计数器不可以被重置，CyclicBarrier的计数器可以被重置，因此它被称为循环的barrier。 Semaphore： 初始化建立N个信号量。调用acquire()获取指定数量的信号量，如果有就给，没有就阻塞。调用release()释放指定数量的信号量。 线程池ThreadPoolExecutor是线程池类 线程池的七大参数： corePoolSize：创建线程池之后，线程池中线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务防到缓存队列中。核心线程会一直存活，即使没有任务需要执行。 maximumPoolSize：线程池的最大线程数，表示线程池中最大能创建多少个线程。 keepAliveTime：非核心线程的最大空闲时间。超过线程会被销毁。 unit：keepAliveTime的单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程工厂，用于创建线程，一般用默认的即可。 rejectedExecutionHandler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 线程池工作过程： 当线程池刚创建时，里面没有线程，任务队列是作为参数传进来的，就算任务队列中有任务，线程池也不会马上执行他们。 当调用execute()方法添加一个任务时，线程池会做出如下判断： 如果poolSize &lt; corePoolSize，则新增加一个线程处理新的任务。无论是否有空闲的线程都新增一个线程处理新提交的任务。 如果poolSize = corePoolSize，新任务会被放入阻塞队列等待。 如果阻塞队列的容量达到上限，且这时poolSize &lt; maximumPoolSize，新增线程来处理任务。 如果阻塞队列满了，且poolSize = maximumPoolSize，那么线程已经到达极限，会根据拒绝策略拒绝新任务。 当一个线程完成任务时，他会从队列中取下一个任务来执行。 当一个线程空闲时，超过一定时间（keepAliveTime）时，线程池会进行判断，如果当前运行的线程数大于corePoolSize，那么这个线程就会停掉。所以线程池所有任务完成后，它最终会收缩到corePoolSize的大小。 饱和策略： ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃新任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃最老的请求，也就是即将被执行的任务，并尝试再次提交当前任务 ThreadPoolExecutor.CallerRunsPolicy：由调用方的线程处理新任务，不用线程池中的线程处理。 阻塞队列： workQueue：一个阻塞队列：一般使用LinkedBlockingQueue和Synchronous。 workQueue的类型为BlockingQueue，通常去下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小。 LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定大小，则默认为Integer.MAX_VALUE。 synchronousQueue：这个队列不会保存提交的任务，而是直接创建一个线程来执行新来的任务。 Executors类实现的几种线程池类型，阿里为什么不让用？ FixedThreadPool：该方法返回一个固定线程数量的线程池。当新任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，等待有线程空闲，再处理在任务队列中的任务。 SingleThreadExecutor：该方法返回一个只有一个线程的线程池。多余的任务提交时，保存到任务队列，待线程空闲时，按先进先出顺序执行队列中的任务。 CachedThreadPool：该方法返回一个可以根据实际情况调整线程数量的线程池。线程池中线程的数量不确定，若有空闲的线程，可以优先使用空闲线程。若所有线程都在工作，又有新任务提交，则会创建新的线程执行任务。所有线程执行完任务后都将返回线程池进行复用。 不用的原因： FixedThreadPool和SingleThreadExecutor都使用LinkedBlockingQueue作为阻塞队列，存在等待队列无限长的问题，造成OOM。 CachedThreadPool使用SynchronousQueue作为阻塞队列，它不会保存任务，新任务提交后直接创建临时线程处理，会造成无限制的创建线程，造成OOM。 乐观锁每次访问数据都认为其他线程不会修改数据，所以直接访问数据，更新的时候再判断在此期间其他线程是否修改数据。 实现： CAS机制：无锁算法。需要读写的内存值V和旧的期望值A相同时，更新为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。 版本号机制：为数据添加一个version字段，表示修改次数，在读取数据的同时读取version字段，在提交更新时，若刚才读取的version值和当前数据的version字段相等时才提交更新，否则重新尝试，直到成功。 乐观锁的缺点： 1. ABA问题： 变量初次读取和准备赋值时数值相等不代表该变量在此期间没被更改过，有可能被改为其他值又改了回来。可以用AtomicStampedReference类的compareAndSet方法，首先检查当前引用是否等于预期引用，当前标志是否等于预期标志，如果全部相等，再以原子方式将该引用和该标志的值设置为给定的更新值。 2. 循环时间长，开销大 自旋CAS如果一直不成功，开销大。 3. 无法用于共享变量 只对单变量有用，无法适用于共享变量。 CAS如何保证原子操作： CAS是通过硬件命令保证了原子性。 悲观锁定义：每次访问数据的时候都认为其他线程会修改数据。所以先获得锁，再访问数据。 实现：synchronized和ReentrantLock。 synchronized：####用法： 修饰实例方法：给当前实例对象加锁。 修饰静态方法：给当前类加锁。 修饰代码块：指定加锁对象，如果给.class结尾则是给类加锁，否则是给对象加锁。 底层实现： 无论是同步代码块还是同步方法，都是基于进入和退出Monitor对象实现的。Monitor对象存在于每个对象的对象头中。 同步代码块是根据monitorenter和monitorexit指令实现的。 同步方法是通过设置方法的ACC_SYNCHRONIZED访问标志。 公平锁和非公平锁公平锁：线程依次排队获取锁。 非公平锁：线程不管是不是队头都能获取锁。 效率：公平锁要维护一个队列，后来的线程要想获取锁，即使锁空闲，也要先检查有没有其他线程在等待获取锁，如果有，自己就要挂起，加到队列后面，然后唤醒队列最前面的线程。这种情况下相比非公平锁多了一次挂起和唤醒。非公平锁减少了线程被挂起的几率，所以效率较高。 锁优化###自旋锁 原理：如果持有锁的线程能在很短时间内释放锁，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要做自旋操作，等一等，等待持有锁的线程释放锁后即可立即获得锁。这样就避免了线程在内核态和用户态之间切换进入阻塞状态，提高了效率。 改善：1.6引入自适应自旋锁，自旋时间由上一次同一个锁的自旋时间以及锁的拥有者的状态来决定。 锁消除锁消除是编译级别的事情，在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。 锁粗化虚拟机探测到一系列操作都对同一个对象加锁解锁，就将加锁的范围粗化到整个操作系列的外部。 偏向锁使用场景：大多数情况下虽然加了锁，但是没有竞争发生，甚至同一个线程反复获得这个锁。 类比例子：一个仓库管理员管着钥匙，然而每一次都是老王去借，仓库管理员于是就认识了老王，直接和他说，“行，你直接拿就是不用填表格了我记得你”。 原理：当一个线程访问同步代码块并获取锁时，会在对象头中的Mark Word里存储锁偏向的线程ID，并把偏向锁标志为写成1。在线程进入和退出同步代码块时不需要通过CAS操作来加锁减锁，只需要在置换线程ID时候执行一次CAS原子操作即可。当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，首先暂停拥有偏向锁的线程，判断该对象是否处于处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为01）或者轻量级锁（标志位为“00”）的状态。 轻量级锁当锁是偏向锁的时候，被另外的线程所访问，偏向锁，就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。 加锁过程：JVM在当前线程的栈帧中创建用于存储锁记录的空间，叫做LockRecord，然后把Mark Word拷贝到LockRecord中，同时生成一个叫owener的指针指向那个加锁的对象。同时，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向那个Lock Record的指针。如果更新成功了，那么该线程就拥有了该对象的锁。如果更新失败，JVM会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有个这个对象的锁，可以直接进入同步块继续执行，否则说明多个线程竞争锁，升级为重量级锁。 重量级锁升级为重量级锁时，锁标志的值为“10”，此时Mark Word中存储着指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。","categories":[],"tags":[]},{"title":"JAVA并发基础","slug":"concurrent","date":"2020-05-03T17:48:05.000Z","updated":"2020-05-21T19:07:45.000Z","comments":true,"path":"2020/05/03/concurrent/","link":"","permalink":"http://yoursite.com/2020/05/03/concurrent/","excerpt":"","text":"说说并发和并行的区别 并发：同一时间段内，多个任务都在执行（单位时间内不一定同时执行）。 并行：单位时间内，多个任务同时执行。 线程安全和非线程安全 线程安全：一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能正常运行，我们就称是线程安全的。 非线程安全：一个类在单线程环境下正常运行，在多线程环境下无法正常运行，这个类就是非线程安全的。 为什么要使用多线程先从总体上来说： 从计算机底层来讲：线程的切换和调度成本远远小于进程。在单核CPU时代，多线程主要是为了提高CPU和IO设备的综合利用率；在多核CPU时代，多线程主要是为了提高CPU利用率，让多个CPU核心被利用到。 从互联网发展趋势来讲，现在的系统要求高并发量，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别A.start()是启动一个新线程，进入就绪状态，start方法只能被调用一次。 run()方法，就绪状态的线程获取cpu之后调用的，线程进入运行状态，如果手动调用，相当于执行一个普通的方法。 wait()/notify()方法：线程调用wait()方法，释放对象的锁，进入该对象的等待队列，其他线程调用notify/notifyAll()方法唤醒等待队列中的线程，线程进入锁池，等待获取对象锁，获取之后进入就绪状态。 为什么wait和notify方法要放入synchronized代码块中： wait()的含义是释放对象的锁，并将线程放入该对象的等待队列，要想释放锁必须先拥有锁，所以wait()要放入 synchronized同步代码块中。 notify方法是通知等待队列中的线程进入锁池，准备获取锁，只有当获取到该对象的琐时，才有资格通知其他线程去做好准备获取锁。 为什么wait()方法要放在while()循环中 对于从等待队列中唤醒的线程来说，被唤醒后还需要检查是否符合执行条件，如果不符合，就再次被wait。 yield()方法：Thread的静态方法，表示当前线程从运行状态转入就绪状态，不会释放任何锁。 sleep()方法：Thread的静态方法，表示当前线程从运行状态转入阻塞状态，不释放任何锁，休眠一段时间后，该线程进入就绪状态。 join()方法：假如A线程调用join()方法，则当前线程进入阻塞状态，等线程A执行完成之后，当前线程从阻塞状态进入就绪状态。 interrupt()：调用interrupt()，中断标志设置为true，当线程处于wait(), join(), sleep()等阻塞状态时，清除中断标记，抛出InterruptException异常，通过代码捕获异常，break跳出循环，线程结束。 isInterrupted()：当线程未处于阻塞状态，通过isInterrupted()方法检查中断标志位来退出循环。相比于interrupted(), 此方法不会清除标志位。 Executor的中断：shutdown()中断和shutdownNow()中断，区别是shutdown()不接受新的，等待线程中所有的任务完成。shutdownNow()不接受新的和未处理的，调用每个正在执行的线程的interrupt()。 中断线程池中的一个线程：使用submit方法提交线程，会返回一个future对象，调用该对象的cancel方法中断线程。 使用多线程可能带来什么问题肯能会存在：内存泄漏，上下文切换，死锁还有受限于硬件和软件的资源闲置问题。 说说线程的生命周期和状态线程有六个状态：NEW，RUNNABLE，BLOCKED，WAITING，TIME_WAITING，TERMINATED。 什么是上下文切换当前任务执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以加载这个任务的状态。 什么是死锁，如何避免死锁死锁产生的四个条件多个线程同时被阻塞，它们中的一个或多个全部都在等待某个资源被释放。 产生死锁必须具备以下四个条件： 互斥条件：该资源任意时刻只由一个线程占用。 请求于保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其它线程强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如何避免死锁我们只要破坏产生死锁的四个条件中的一个就可以了。 破坏互斥条件这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件一次性申请所有资源 破坏不剥夺条件占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件靠按序申请资源来预防。按照某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。 说说sleep（）方法和wait（）方法的区别和共同点 两者的主要区别是：sleep（）方法没有释放锁，而wait方法释放了锁。 两者都可以暂停进程的执行。 Wait通常用于进程间的交互／通信，sleep（）通常用于暂停执行。 wait（）方法被调用后线程不会自动苏醒，需要别的线程调用同一个对象上的notify（）或者notify（）方法。sleep（）方法执行完成后，线程会自动苏醒。或者可以使用wait（long timeout），超时后线程会自动苏醒。 为什么我们调用start（）方法时会执行run（）方法，为什么我们不能直接调用run（）方法调用start（）方法可以启动线程并使线程进入就绪状态，而run方法只是线程的一个普通方法调用，还是在主线程里执行。","categories":[],"tags":[]},{"title":"Java类加载过程","slug":"Java-class-load-process","date":"2020-05-03T06:36:28.000Z","updated":"2020-05-07T23:56:06.000Z","comments":true,"path":"2020/05/02/Java-class-load-process/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-class-load-process/","excerpt":"","text":"Java类加载过程虚拟机加载Class类型的文件主要分为三步：加载，连接，初始化。连接过程又可分为三步：验证，准备，解析。 加载 通过全类名获取定义此类的二进制字节流。 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。 验证这一步的目的是确保class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机自身的安全。 准备准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都是在方法区中进行分配。 解析解析阶段是将虚拟机常量池内的符号引用替换为直接引用的过程 初始化初始化阶段是执行类构造器方法的过程。","categories":[],"tags":[]},{"title":"Java_memory_area","slug":"Java-memory-area","date":"2020-05-03T05:32:44.000Z","updated":"2020-06-15T07:45:11.000Z","comments":true,"path":"2020/05/02/Java-memory-area/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-memory-area/","excerpt":"","text":"Java内存区域详解运行时的数据区域 程序计数器（Program Counter Register）：记录下一条执行字节码指令的地址。唯一不会发生OutofMemory的地方。作用有两个：（1） 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行，选择，循环，异常处理。（2）在多线程的情况下，程序技术器用来记录当前线程执行位置，从而当线程切换回来的时候能够知道线程上次运行到哪。 Java虚拟机栈：存放Java方法的栈。实际上，Java虚拟机栈是由一个个栈帧组成的，每个栈帧中都有局部变量表，操作数栈，动态链接，方法出口信息。其中局部变量表中存放了基本数据类型和对象引用。 本地方法栈：虚拟机使用到的Native方法的内存模型，其余与虚拟机栈非常相似。 堆：此内存区域唯一目的就是存储对象实例，几乎所有的对象实例以及数组都在这里分配内存。 方法区：用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。在JDK 1.8中被元空间代替，元空间位于直接内存，不受JVM大小限制，直接受限于内存。 常量池：1.8之前放在方法区，1.8之后放在堆中，主要有字面量（字符串基本数据类型final修饰的常量）和符号引用。 JDK1.8和JDK1.7的区别JDK1.8中用元空间代替方法区，并且位于直接内存中； JDK1.8将常量池从方法区放入堆中。 方法区和永久代的关系方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，是HopSpot的概念。 常用参数JDK1.8之前用PermSize和MaxPermSize来调节方法区大小。 JDK1.8的时候，方法区被移除，取而代之的是元空间，元空间使用的是直接内存。常用参数为MetaspaceSize和MaxMetaspaceSize。 为什么要将永久代替换为元空间？ 永久代有一个JVM本身设置固定大小上限，无法进行调整，容易出现内存溢出，而元空间使用的是直接内存，受本机可用内存限制，比原来出现溢出的概率小。 元空间里面存放的是类的元数据，加载多少类的元数据不由maxpermsize控制，而由系统的实际可用空间来控制，加载类更多了。 在JDK8，合并HotSpot和JRockit代码时，JRockit从来没有一个叫永久代的地方，合并之后就没有必要额外的设置这么一个叫永久代的地方。 运行时的常量池运行时常量池是方法区的一部分，用于存放编译时生成的各种字面量和符号引用。 直接内存直接内存时Java虚拟机之外的内存，但也有可能被Java使用。 在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。 堆内存分配策略： 对象优先在新生代的Eden区进行分配。 大对象（长字符串和数组）直接进入老年代。 长期存活的对象进入老年代。一次Minor GC，年龄加一，默认年龄为15时进入老年代。 动态年龄判断。相同年龄所有对象大小的总和大于Suvivor空间的一半，大于等于该年龄的对象进入老年代 空间分配担保在堆空间中，eden区和suvivor区的比例为8:1，空间担保是指suvivor区域容纳不下存活的对象，则把容纳不下的对象放入老年代。 在Minor GC之前，检查老年代的最大的可用的连续内存空间是否大于新生代所有对象总和，如果是，则此次minor GC是安全的，如果不是，则有失败的风险；也可以根据以往进入老年代对象大小的平均值来判断是否进行此次minor GC，如果执行失败或者不执行，则进行Full GC。 Full GC触发条件： 老年代空间不足。 方法区空间不足。 调用System.gc()建议JVM进行full GC。 没有足够的连续内存空间分配给大对象。 长期存活的对象转入老年代，空间不足。 新生代垃圾回收存活的对象太多，s1放不下，老年代空间担保不足， 判断对象是否存活 引用计数法：给对象添加一个引用计数器，每次被引用，计数器加一；引用失效，计数器减一。当引用数为0时，表示对象不存活。但无法解决循环引用的问题。 可达性分析法：以GC roots为起点，向下搜索，节点所走的路径成为引用链。当一个对象和引用链没有相连时，表示这个对象不可达。GC roots：虚拟机栈的引用对象，本地方法栈的引用对象，方法区的静态变量引用的对象，方法区常量引用的对象。 回收对象的两次标记过程： 可达性分析的不可达对象，并不马上回收，要经过两次标记： 第一次标记：对可达性分析中对不可达的对象进行第一次标记，并进行筛选。 第二次标记：筛选条件是重写finalize（）方法并且没有调用的对象，将其放入队列，进行第二次标记。在执行finalize时，如果该对象依然没有被引用，才被真正的回收。finalize方法只能被调用一次。 引用类型：强引用：new的对象，垃圾回收器不会回收他。 软引用： 空间不足时，回收这些对象的内存。 弱引用： 只要发现，马上回收。 虚引用： 任何时刻都可以被回收。 创建一个对象的步骤 类加载检查，先检查对象所属的类是否已经被加载，解析，初始化过，如果没有，先进行类加载过程。 分配内存，为对象分配内存（两种分配方法：碰撞指针（标记整理）和空闲列表（标记清除）） 初始化为0值，将对象中除了对象头的字段都初始化0值。 设置对象头，包括类的元数据信息，对象的哈希码，对象年龄等。 执行init方法，对对象真正初始化。 类加载过程类加载过程：虚拟机将Class文件加载到虚拟机中，并初始化。主要有三部：加载，链接，初始化。链接又分为三部：验证，准备，解析。 加载：主要有三部： 通过全类名获取类的二进制字节流。 将类的静态存储结构转化为方法区运行时的数据结构 在内存中生成类的对象，作为方法区数据的入口。 验证： 对文件格式，元数据，字节码，符号引用等验证正确性。 准备：在方法区为类对象分配内存并设置为0值。 解析：将符号引用转化为直接引用。 初始化：执行类构造器clinit方法，真正初始化。 类加载器 BootstrapClassLoader：启动类加载器。除了他其他类加载器都继承自Java.Lang.ClassLoader。加载/lib下的jar包和类。 ExtensionClassLoader：扩展类加载器。加载/lib/ext目录下的jar包和类。 AppClassLoader：应用类加载器。加载当前classPath下的jar包和类。 双亲委派机制一个类加载器收到类加载请求时，首先判断当前类是否被加载过，如果被加载过，直接返回，如果没被加载过，则将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才会自己加载。 好处： 避免了类的重复加载（相同的类被不同的类加载器加载会产生不同的类），保证java程序运行的稳定。 保证核心API不被修改。比如自定义一个不安全的Integer类，则该类永远不会被调用，因为采用双亲委派机制，启动类加载器加载默认的Integer类，而不是自定义的Integer类。 如果创建自定义类加载器： 继承classLoader，重写findClass()方法，调用defineClass()方法。 如何破坏双亲委派机制： 重写loadClass方法，将自行加载放到委托父类加载器加载之前。 如何创建对象 用new关键字。 调用对象的clone方法。 利用反射获取类对象，调用Class类或者Constructor类的newInstance()方法。 用反序列化，调用ObjectInputStream的readObject（）方法。 ThreadLocal##定义： ThreadLocal：让线程访问某个变量时拥有自己的线程局部变量，避免了线程间的竞争问题。 ##原理： 每个线程都有一个ThreadLocalMap，存储以ThreadLocal为key的键值对。 内存泄漏ThreadLocalMap中的key是ThreadLocal的弱引用，可以被回收，value是强引用，不可以被回收。为了避免ThreadLocal为null而value不为null的情况，在调用ThreadLocalMap中的get和set方法时，会对key进行判断，如果为null，则把value也设置为null。也可以调用ThreadLocal的remove方法，清理key为null的value。 Java内存模型可以把内存模型简化为主内存和线程本地内存。线程可以把变量从主内存读到本地缓存，然后在本地缓存中进行读写，然后将改变结果写到内存中。这就导致了线程本地内存和主内存数据不一致的情况。即可见性，volatile可以解决这个问题。 volatile关键字被volatile修饰的共享变量，具有以下两点特性： 保证了不同线程对该变量操作的内存可见性。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主内存，当其他线程需要读取该变量时，会从主存中读取新值。而普通变量则不能保证这一点。 虚拟机会使用内存屏障禁止指令重新排序保障其有序性。 底层实现：volatile修饰的变量会在汇编阶段多出一条lock前缀指令，导致当前处理器缓存的数据立刻写回到主内存中，且让其他修改该数据的处理器的缓存失效。是synchronized的轻量级实现，只能保证可见性，无法保证原子性。 参考链接Java Guide","categories":[],"tags":[]},{"title":"JAVA集合框架","slug":"Java-Collection","date":"2020-05-03T01:12:18.000Z","updated":"2020-05-17T19:36:49.000Z","comments":true,"path":"2020/05/02/Java-Collection/","link":"","permalink":"http://yoursite.com/2020/05/02/Java-Collection/","excerpt":"","text":"#常见集合框架 Java中常见的集合框架有List，Set，Map： List：存储一组不唯一，有序的对象。如ArrayList，LinkedList。 Set：不允许重复的集合，HashSet无序，TreeSet有序。 Map：使用键值对存储。两个Key可以引用相同的对象，但Key不能重复。HashMap无序，TreeMap有序。 ArrayList与LinkedList区别？ ArrayList: 采用object数组存储 默认长度是10，扩容是变成1.5倍 扩容是采用Arrays.copyOf()创建新的数组 增加和删除操作会造成元素移动，使用System.arraycopy() 支持随机访问。 Vector： 低层实现是Object数组，与ArrayList不同的是Vector线程安全。 默认长度是10，扩容倍数默认为2，可以通过capacityIncrement参数自定义。 LinkedList： 使用双向链表实现 不支持随机访问，但插入删除操作不受位置影响。 区别： ArrayList底层数据结构使用Object数组，LinkedList底层使用的是双向链表数据结构 ArrayList采用数组存储，所以插入和删除元素需要移动元素向前或向后，效率较低。LinkedList采用链表存储，只需要改变元素指针即可，效率较高. ArrayList支持高效快速的随机访问，LinkedList不支持高效快速的随机访问 ArrayList空间浪费主要体现在在list列表结尾会预留一定的容量空间。而LinkedList的空间花费则体现在每一个元素要消耗比ArrayList更多的空间（因为要存放前驱指针，后继指针以及数据）。 Collections.synchronizedList&lt;&gt;: 可以用此方法实现ArrayList和LinkedList的线程安全。 HashMap和HashTable的区别 线程是否安全：HashMap是非线程安全的，HashTable是线程安全的。 效率：因为线程安全的问题，HashMap要比HashTable效率高一点。 对Null key和Null value的支持：HashMap中，null可以作为主键，这样的键只有一个，可以有一个或多个键所对应的值为null。 初始容量和每次扩充容量大小的不同：创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n + 1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，HashTable会直接用你给定的大小，而HashMap会将其扩充为2的幂次方大小。 底层数据结构：HashMap在解决哈希冲突时有了较大的变化，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间。","categories":[],"tags":[]},{"title":"线程安全的集合对象","slug":"thread-safe-collection","date":"2020-05-02T18:28:02.000Z","updated":"2020-05-02T23:36:18.000Z","comments":true,"path":"2020/05/02/thread-safe-collection/","link":"","permalink":"http://yoursite.com/2020/05/02/thread-safe-collection/","excerpt":"","text":"线程安全线程安全就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他进程才可以使用。不会出现数据不一致或者数据污染。 线程安全的集合对象 ArrayList线程不安全，Vector线程安全。 HashMap线程不安全，HashTable线程安全。 StringBuilder线程不安全，StringBuffer线程安全。 把非线程安全的集合转换为线程安全可以用Collections.synchronizedList，把ArrayList转化为线程安全的List。与此类似的，还有HashSet，LinkedList，HashMap等等非线程安全的类。","categories":[],"tags":[]},{"title":"Java fundamentation","slug":"Java-fundamentation","date":"2020-05-02T00:33:24.000Z","updated":"2020-06-12T23:04:14.000Z","comments":true,"path":"2020/05/01/Java-fundamentation/","link":"","permalink":"http://yoursite.com/2020/05/01/Java-fundamentation/","excerpt":"","text":"JAVA基础String，StringBuffer，StringBuilder区别##可变性： String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，没有用final关键字修饰，所以这两种对象都是可变的。 线程安全性String中的对象是不可变的，可以理解为常量，线程安全。 StringBuffer对方法加了同步锁，所以是线程安全的。 StringBuilder没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变时，都会生成一个新的对象，然后将指针指向新的String对象。 StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用StringBuilder比使用StringBuffer仅能获得10%-15%左右的性能提升，但却要冒多线程不安全的风险。 总结操作少量数据：适合用String。 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder。 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。 为什么String是不可变类，有什么好处 字符串常量池的需要：字符串常量池是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假设此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。假如字符串对象允许改变，那么将导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象 允许String对象缓存HashCode：Java中String对象的哈希码被频繁地使用，比如在HashMap等容器中。字符串的不变性保证了哈希码的唯一性，不必每次都去计算新的哈希码，因此可以放心的进行缓存。 安全性：String被许多类当作参数，例如网络链接地址URL，文件路径Path，还有反射机制所需要的参数等，假设String不是固定不变的，将会引起各种安全隐患。 #面向对象特性： 继承：从已有类得到继承信息创建新类的过程。 封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。 多态：允许不同子类型的对象对同一消息作出不同的响应。实现方法：Overload和Override，接口，抽象类。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程 。 与C++区别： Java 是面向对象语言，所有的对象都继承自 java.lang.Object，C++即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 抽象类和接口的区别不同： 抽象类中可以定义构造器，接口中不能定义构造器 抽象类可以有抽象方法和具体方法，接口中的方法全部都是抽象方法 抽象类中的成员可以是private, 默认，protected， public，接口中的成员全都是public 抽象类中可以定义成员变量，接口中定义的成员变量实际上都是常量 抽象类中可以有静态方法，接口中不能有静态方法 一个类只能继承一个抽象类，一个类可以实现多个接口 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 相同： 都不能被实例化。 可以将抽象类和接口类型作为引用类型。 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象对象。 泛型和泛型擦除 泛型：泛型即参数化类型，创建集合时指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。 泛型擦除：泛型类型信息在编译时被擦除。主要过程如下：将所有泛型参数用最顶级的父类型替换，移除所有参数类型。list中加入无继承关系的对象时，可以利用反射绕过编译器调用add方法。 Java异常体系：以Throwable作为所有异常的超类，将异常划分为两类：Error和Exception。 Error（错误）：表示程序无法处理的错误，一般是程序运行时JVM出现问题。例如：StackOverflowError，OutOfMemoryError。 Exception（异常）：程序本身可以可以捕获并处理的异常。分为运行时异常和编译时异常。 运行时异常：RuntimeException及其子类，如NullPointerException, ArrayIndexOutBoundException, ArithmeticException。 编译时异常：编译时出现的异常，必须进行处理，否则便已不通过，例如：IOException，ClassNotFoundException，InterruptedException。 Java内存泄漏：长生命周期的对象持有短生命周期对象的引用，而导致短生命周期的对象不能被引用。例如集合持有引用，单例对象持有引用。 static和final关键字： static: 修饰成员变量：在类被初次加载时初始化，在内存中只存在一个副本，存在于方法区，被所有对象共享。 修饰成员方法：不依赖对象实例就可以被调用，静态方法不可以访问类中的非静态方法和变量。 修饰代码块：在类加载时执行一次，适用于只进行一次的初始化操作。 修饰内部类：不需要通过外部类的对象建立；不可以访问外部类的非静态成员和方法。 final： 修饰变量：修饰变量表示常量，赋值后引用不可修改。 修饰方法：表示方法不可以被重写 修饰类：表示类不可以被继承。还可以通过修饰父类的构造函数为private来禁止继承。 序列化和反序列化 序列化：将对象转化成字节序列，以便在网络中传输或保存到本地。 反序列化：把字节序列恢复成java对象的过程。以便在网络中获读取文件的时候，根据字节流的信息，通过反序列化重建对象。 反序列化失败的场景： 没有添加serialVersionUID 继承了一个实现了序列化借口的父类，并且与父类有重复的属性，则在反序列化的过程中会导致重复的属性数据丢失。 fail-fast和fail-safe： Fail-fast：List中维护一个modCount变量，add，remove，clear等涉及了改变list元素个数的方法都会导致modCount改变。如果判断出modCount != expectedModCount，则抛出ConcurrentModificationException异常。 解决办法： Collections.synchronizedList或者给每个访问操作加入synchronized关键字，但有可能阻塞便利操作。 CopyOnWriteArrayList来代替ArrayList。具体方法是任何对list的结构有改变的操作，都会先复制现有的数据，然后在复制的数据上作修改，修改完毕之后直接改变原有数据的引用即可。代价就是产生大量的对象，同时copy操作也是有损耗的。 fail-safe：在遍历时不是直接在集合内访问，而是拷贝原有集合内容，在拷贝的集合上进行遍历。 问题： 需要复制集合，开销大 无法保证遍历时是最新数据。 #常见集合框架 Java中常见的集合框架有List，Set，Map： List：存储一组不唯一，有序的对象。如ArrayList，LinkedList。 Set：不允许重复的集合，HashSet无序，TreeSet有序。 Map：使用键值对存储。两个Key可以引用相同的对象，但Key不能重复。HashMap无序，TreeMap有序。 ArrayList与LinkedList区别？ ArrayList: 采用object数组存储 默认长度是10，扩容是变成1.5倍 扩容是采用Arrays.copyOf()创建新的数组 增加和删除操作会造成元素移动，使用System.arraycopy() 支持随机访问。 Vector： 低层实现是Object数组，与ArrayList不同的是Vector线程安全。 默认长度是10，扩容倍数默认为2，可以通过capacityIncrement参数自定义。 LinkedList： 使用双向链表实现 不支持随机访问，但插入删除操作不受位置影响。 区别： ArrayList底层数据结构使用Object数组，LinkedList底层使用的是双向链表数据结构 ArrayList采用数组存储，所以插入和删除元素需要移动元素向前或向后，效率较低。LinkedList采用链表存储，只需要改变元素指针即可，效率较高. ArrayList支持高效快速的随机访问，LinkedList不支持高效快速的随机访问 ArrayList空间浪费主要体现在在list列表结尾会预留一定的容量空间。而LinkedList的空间花费则体现在每一个元素要消耗比ArrayList更多的空间（因为要存放前驱指针，后继指针以及数据）。 Collections.synchronizedList&lt;&gt;: 可以用此方法实现ArrayList和LinkedList的线程安全。 HashMap和HashTable的区别 线程是否安全：HashMap是非线程安全的，HashTable是线程安全的。 效率：因为线程安全的问题，HashMap要比HashTable效率高一点。 对Null key和Null value的支持：HashMap中，null可以作为主键，这样的键只有一个，可以有一个或多个键所对应的值为null。 初始容量和每次扩充容量大小的不同：创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n + 1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，HashTable会直接用你给定的大小，而HashMap会将其扩充为2的幂次方大小。 底层数据结构：HashMap在解决哈希冲突时有了较大的变化，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间。 HashMap面试指南###看过HashMap源码嘛，知道原理吗？ HashMap底层是数组+链表+红黑树。首先是table数组，数组中存放的是链表，链表的每一个节点以键值对的形式存在。在JDK1.8之后，当链表的长度超过阈值，默认为8，为加快检索速度，将链表转化为红黑树。 为什么用数组+链表？ 数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到。 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组对应位置形成一条链表。 用LinkedList代替数组结构可以么?是可行的，但是用数组的效率最高。在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。得到桶的位置，数组的查找效率比LinkedList高。采用基本的数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算时候效率高。而ArrayList的扩容机制是1.5倍扩容。 HashMap在什么条件下扩容？默认负载因子为0.75，初始容量为16，如果bucket数量超过了load factor * current capacity, 就要扩容。load factor为0.75，current capacity为当前数组大小。 为什么扩容是2的次幂?HashMap再分配数据到对应链表时，进行取模运算，但是这种运算不如位运算快，所以在源码中做了优化，将hash%length取模改成hash&amp;(length - 1), 2的n次方-1的二进制实际上就是n个1，保证hash值与（length - 1）做与运算的时候，每一位都能&amp;1，保证了不同位置不会发生碰撞。 Hash值为什么将HashCode的高十六位与低十六位进行异或操作？减小hash值的碰撞几率。 讲讲HashMap的put过程？对key的hashcode做hash运算得到index，如果没碰撞直接放到bucket里；如果碰撞了，以链表形式存在bucket后；如果碰撞导致链表过长，就把链表转化成红黑树，如果节点已经存在就替换之前的value，如果bucket满了就要扩容。 讲讲HashMap的get过程？对key的hashcode做hash运算，现将hashcode右移十六位，异或，取余找到在数组中的位置，然后在链表或红黑树中搜索。 链表转化为红黑树的阈值为8，红黑树转化为链表的阈值为6根据概率统计8作为阈值，选择6是为了作为缓冲，避免在链表和红黑树之间的频繁转换。 HashMap多线程put操作导致死循环问题 多线程同时对一个数据操作时可能会覆盖修改，造成数据丢失。 扩容时链表节点采用头插入法插入新的哈希数组有可能会产生循环链表，造成死循环。当JDK1.8扩容时，将原节点用尾插法将节点插入到新的hashmap中。 ConcurrentHashMap： JDK 1.7: 将整个数组分割成多个segment，并且每一段数据配一把锁。当一个线程占用锁访问一段数据时，其他段的数据依然可以被其他线程所访问。Segment实现了ReentrantLock，所以Segment是一种可重入锁。Segment数量是由concurrentcyLevel决定的，默认是16，也是2的N次方。在ConcurrentHashMap中定位元素需要经过两次hash，第一次先定位到Segment，第二次对应到相应的bucket。 JDK 1.8: 采用数组+链表／红黑树的数据结构。并发控制采用CAS+synchronized。put操作时，判断hash值所对应的bucket是否为null，如果为null，采用CAS写入，否则synchronized加锁写入，当链表长度超过8时，将链表转化为红黑树。synchronized只锁定链表或红黑树的首节点，只要不发生hash冲突，就不会产生竞争，提升效率。","categories":[],"tags":[]},{"title":"cluster index VS non cluster index","slug":"cluster-index-VS-non-cluster-index","date":"2020-05-02T00:20:00.000Z","updated":"2020-06-04T21:31:36.000Z","comments":true,"path":"2020/05/01/cluster-index-VS-non-cluster-index/","link":"","permalink":"http://yoursite.com/2020/05/01/cluster-index-VS-non-cluster-index/","excerpt":"","text":"聚集索引和非聚集索引的区别 聚集索引：数据文件本身就是索引文件。B+树叶子节点的data域完整保存了数据记录。索引的key是数据表的主键。其余的索引为辅助索引，辅助索引叶子节点data域存放的是对应的主键的值，查找时先在辅助索引中获取主键值，然后在聚集索引中获取完整的数据记录。所以在设计表时不建议用过长的字段作为主键。聚集索引用于InnoDB存储引擎中。 非聚簇索引：B+树叶子节点data域存放的是数据记录的地址。MyISAM存储引擎所使用，索引文件和数据文件分离。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"如何对一条SQL语句进行调优","slug":"optimize-sql","date":"2020-05-01T17:10:38.000Z","updated":"2020-06-05T01:46:44.000Z","comments":true,"path":"2020/05/01/optimize-sql/","link":"","permalink":"http://yoursite.com/2020/05/01/optimize-sql/","excerpt":"","text":"explain指令explain命令输出的结果有10列： id：值越大，优先级越高，越先被执行。 select_type： SIMPLE：不包含UNION或subQuery。 PRIMARY：查询包含UNION或子查询，则最外层的查询为PRIMARY。 SUBQUERY：子查询中的第一个select语句 DERIVED：包含在from子句中的子查询。 table：显示正在访问哪个表。 type：表示MySQL在表中查找所用的方式。有ALL，index，range，ref，eq_ref, const, system, null从左到右性能依次变好。 possible_keys：可能用那些索引来查找。 key：实际决定使用哪些索引。 key_len：索引实际使用的字节数。 ref：表示那些字段或者常量用来喝索引配合从表中查询记录。 rows：估计要找到记录所需读取的行数。 extra：其他信息，比如Using index，使用覆盖索引，用索引就可以找到数据信息，不需要进行回表操作。 如何对一条SQL语句进行调优 尽量选择字段长度较小的列 将where及order by语句中涉及比较频繁的列建立索引 select子句中避免使用“*”，应指定具体的列名。 当只需要一行数据的时候使用limit 1 避免在where子句中使用 ！=或者&lt;&gt;操作符，否则引擎将放弃索引使用全表扫描 in和not in也要慎用，否则会导致全表扫描，对于连续的数值，可以用between代替in 如果查询的两个表大小相当，用in和exists和in差别不大，当子查询表大时，可以用exists，子查询表小的时候用in。not in和not exists相比时，无论哪个表大，用not exists都比not in快，此外not in可能会产生逻辑错误，子查询所返回的记录中不可以有空值。 避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 保证表单数据不超过200w，适时分割表 针对查询较慢的语句，可以使用explain来分析该语句具体的执行情况 避免查询时判断null，否则可能会导致全表扫描，无法使用索引 避免使用%前缀的like查询，否则可能导致全表扫描，可以考虑使用全文索引，全文索引使用分词器将字段分割成一个个token_text，并且记录这些token_text来自表里的那些行，把这些信息记录到索引中，用空间换时间。 能用union all的时候就不用union，union去重合排序的过程要耗费更多的CPU资源。当然，union all的前提条件是两个结果集没有重复数据。 联合索引如何存储：索引列全部出现在B+书中，首先按照第一列（最左前缀）进行排序，如果相等，则按照第二列进行排序，依次递推。 如何查找：先按照第一列进行查找，再按照第二列进行查找，依次递推。 存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置。范围列可以用到索引，但范围列后面的列无法用到索引。 参考链接MYSQL查询SQL语句性能优化方法 浅谈sql中的in与not in,exists与not exists的区别以及性能分析","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库的四大特性","slug":"database-ACID","date":"2020-04-24T05:47:20.000Z","updated":"2020-04-24T16:52:14.000Z","comments":true,"path":"2020/04/23/database-ACID/","link":"","permalink":"http://yoursite.com/2020/04/23/database-ACID/","excerpt":"","text":"数据库的四大特性事务事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 ACID1. 原子性（Atomicity）事务要么全部提交成功，要么全部失败回滚。 2. 一致性（Consistency）在事务开始前和事务结束后，数据库的完整性约束没有被破坏。 3. 隔离型（Isolation）一个事务所做修改在提交之前，对其他事务是不可见的。 4. 持久性（Durability）一旦事务提交，其所做的修改会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。 事务的ACID特性概念简单，但不是很好理解，主要是因为这几个特性不是平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足，此时只需要满足原子性，就一定能满足一致性。 在并发情况下，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对数据库崩溃的情况。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库引擎","slug":"database-engine","date":"2020-04-23T17:09:11.000Z","updated":"2020-04-23T18:33:23.000Z","comments":true,"path":"2020/04/23/database-engine/","link":"","permalink":"http://yoursite.com/2020/04/23/database-engine/","excerpt":"","text":"在MySQL中，索引属于存储引擎级别的概念，不同的存储引擎对索引的实现方式是不同的，下面介绍MyISAM和InnoDB两个存储引擎的索引实现方式， 1. MyISAM索引实现MyISAM引擎使用的是B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MySAM索引的原理图： 假设表一共有三列，假设以Col1为主键，则上图是MyISAM表的主索引（primary key）。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM索引检索的算法首先按照B+树搜索算法搜索索引，如果指定的key存在，则取出data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的。 #2. InnoDB索引方式 虽然InnoDB也使用B+树作为索引结构，但具体实现方式与MyISAM截然不同。 第一个重大区别是InnoDB的数据文件本身就是按照B+树组织的索引文件，而MyISAM索引文件和数据文件是分离的，索引文件只保存数据记录的地址。InnoDB表数据文件本身就是主索引，B+树的叶节点data域保存了完整的数据记录，这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果没有指定，则MySQL系统会自动选择一个可以唯一表示数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。 第二个与MyISAM索引不同的是InnoDB辅助索引的data域存储相应记录主键的值而不是地址，换句话说，InnoDB的所有辅助索引都引用主键作为data域。 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 InnoDB不建议使用过长的字段作为主键，多长的索引会使辅助索引变得过大。同时不建议使用非单调字段作为主键，因为InnoDB数据文件本身是一棵B+树，非单调的主键会造成在插入新纪录时数据文件为了维持B+树特性而频繁的分裂调整，十分低效，所以选择自增字段作为主键是一个很好的选择。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"-数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库中有哪些索引类型","slug":"database-index-type","date":"2020-04-22T03:39:59.000Z","updated":"2020-06-04T16:35:33.000Z","comments":true,"path":"2020/04/21/database-index-type/","link":"","permalink":"http://yoursite.com/2020/04/21/database-index-type/","excerpt":"","text":"Mysql索引类型与应用场景1. 索引的数据结构1. B+树为什么使用B+树：检索一次最多需要访问h个节点，数据库系统的设计者利用磁盘预读的原理，将一个节点的大小设计成等于一个页，每次新建节点时都申请一个页的空间，保证一个节点物理上存储到一个页里，加之计算机存储分配都是按页对齐的，这样每个节点一次I／O就可以完全载入，B+树在实际应用中的出度非常大，所以高度很小。综上所述，B+树作为索引结构效率非常高。 2. Hash索引（只有Memory存储引擎支持） Hash索引使用Hash算法，把键值转换成Hashcode，存放在索引中，同时哈希表中保存指向每个数据的指针。在检索时一次定位。 Hash 索引只支持等值查询，仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用例如”&gt;”, “LIKE”操作符的范围查询。在没有大量键值重复的前提下，效率有明显的优势。 hash索引无法利用索引进行排序。 不支持多列索引中的最左前缀原则，无法进行部分匹配查找，因为哈希索引使用索引列的全部内容计算哈希值。不过B+树索引因为支持最左前缀原则，支持部分匹配查找。 在有大量重复键值的情况下，哈希冲突很多，维护索引操作的代价也很高，效率变低。 总结：如果是等职查询，哈希索引有绝对优势， 2. 索引的类型 普通索引：最基本的索引，没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值（注意与主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 全文索引（FULLTEXT）：全文索引仅可用于MyISAM表，他们可以从CHAR，VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或者是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更快。 单列索引、多列索引：多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）：对多个列建立索引，遵循最左前缀原则：最左优先，只从最左边的开始组合。 参考文献深入理解索引底层实现","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"top k frequent","slug":"top-k-frequent","date":"2020-04-22T03:14:16.000Z","updated":"2020-04-22T03:34:10.000Z","comments":true,"path":"2020/04/21/top-k-frequent/","link":"","permalink":"http://yoursite.com/2020/04/21/top-k-frequent/","excerpt":"","text":"寻找数据流中出现最频繁的k个元素（find top k frequent items in a data stream）,这个问题也叫heavy hitter。 方案一：HashMap + Heap用一个HashMap记录每个元素出现的次数，用一个小根堆统计目前出现最频繁的k个元素。具体操作如下： 每次来一个元素，如果在HashMap里已经存在，则把对应的计数器加1；如果不存在，则把元素插入HashMap中，并把相应的计数器设置为1. 在堆中查找该元素，如果存在，则把堆里的计数器也加1，并调整堆；如果没有找到，则把这个元素的次数和堆顶元素进行比较，如果大于堆顶元素出现的次数，则用此元素替换堆顶元素，并调整堆。 空间复杂度O(n)。HashMap需要存放下所有元素，需要O(n)的空间，堆需要存放k个元素，需要O(k)的空间，跟O(n)相比可以忽略不急，总的时间复杂度是O(n) 间复杂度O(n)。每次来一个新元素，需要在HashMap里查找一下，需要O(1)的时间；然后要在堆里查找一下，O(k)的时间，有可能需要调堆，又需要O(logk)的时间，总的时间复杂度是O(n(k+logk))，k是常量，所以可以看做是O(n)。 如果元素数量巨大，单机内存存不下，怎么办？ 方案二： 多机 HashMap + Heap 可以把数据进行分片，假设有8台机器，第1台机器只处理hash(elem)%8==0的元素，第2台机器只处理hash(elem)%8==1的元素，以此类推。 每台机器都有一个HashMap和一个 Heap, 各自独立计算出 top k 的元素。 把每台机器的Heap，通过网络汇总到一台机器上，将多个Heap合并成一个Heap，就可以计算出总的 top k 个元素了。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Huffman","slug":"Huffman","date":"2020-04-22T01:37:35.000Z","updated":"2020-04-22T02:56:44.000Z","comments":true,"path":"2020/04/21/Huffman/","link":"","permalink":"http://yoursite.com/2020/04/21/Huffman/","excerpt":"","text":"霍夫曼编码霍夫曼编码的目的是根据使用频率最大化节省字符编码的存储空间，同时可以避免二义性（因为前缀都是内节点，不携带关键数据），主要应用在数据压缩，加密解密等场合。 简单的理解就是，加入有A, B, C, D,, E五个字符，出现的频率分别为5，4，3，2，1，那么第一步先取两个最小权值作为左右子树构造新树，新生成权值为1+2 = 3的节点，再把新生成的节点放到剩下的集合中，再重复以上步骤，取最小的两个权值构成新树。","categories":[{"name":"-计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡二叉树 vs 红黑树","slug":"AVL-vs-RBT","date":"2020-04-19T17:15:47.000Z","updated":"2020-04-20T00:10:46.000Z","comments":true,"path":"2020/04/19/AVL-vs-RBT/","link":"","permalink":"http://yoursite.com/2020/04/19/AVL-vs-RBT/","excerpt":"","text":"AVL树AVL树是一种平衡二叉树，有两个性质： 左右子树高度差小于一 每一个子树均为平衡二叉树 AVL树查找，插入和删除操作具体方式 查找，插入和删除操作的时间复杂度均为Olog(n), 当执行插入或删除操作时，会造成AVL树的不平衡，通过左旋和右旋来恢复平衡。 红黑树也是一种平衡二叉树，有五个性质： 每个节点要么是红色，要么是黑色 根节点是黑色 每个叶子节点（NIL）是黑色 每个红色节点的两个子节点一定都是黑色 任意一个节点到每个可达到的叶子节点的路径都包含数量相同的黑色节点 红黑树查找，插入和删除操作具体方式 查找，插入和删除操作的时间复杂度均为Olog(n),当执行插入或删除操作时，会造成红黑树的不平衡，通过变色，左旋，右旋来恢复平衡。 AVL树和红黑树的区别 AVL树是严格平衡，红黑树不追求完美平衡，所以二者在查找，插入，删除节点时的效率不同 插入节点导致失衡的情况来说，AVL树和红黑树都是最多两次旋转来恢复平衡。但是就删除节点来说，AVL需要维护被删除节点到根节点这条路径上所有节点的平衡，旋转量级为O(logn), 而红黑树最多只需要旋转3次恢复平衡，旋转量级为O(1)。就查找来讲，AVL树遵循严格平衡，查找效率更高，不过红黑树最多多出一层的查找时间。 AVL树针对读取操作时间较快，维护平衡较慢，空间开销大；红黑树读取略慢，维护平衡较快，内容极多时空间开销略优于AVL树。在实际应用中，如果搜索次数远远大于插入和删除，那么选择AVL，如果搜索，插入和删除次数几乎差不多，应该选择红黑树。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"解决哈希冲突常用方法分析","slug":"hash-conflict-solution","date":"2020-04-18T02:12:44.000Z","updated":"2020-04-18T03:33:45.000Z","comments":true,"path":"2020/04/17/hash-conflict-solution/","link":"","permalink":"http://yoursite.com/2020/04/17/hash-conflict-solution/","excerpt":"","text":"解决哈希冲突的方法解决哈希冲突的方法一般有：开放定址法、链地址法、再哈希法，建立公共溢出区等方法。 1. 开放定址法(Open Adressing)1.1 线性探查法(Linear Probing)从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探测完全部单元为止。 f(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1) 1.2 二次探查法（Quadratic Probing）在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。 f(key) = (f(key)+di) MOD m (di = 1^2, -1^2, 2^2, -2^2,……, q^2, -q^2, q &lt;= m/2) 1.3 双散列函数探查法（Double Hashing）这种方法使用两个散列函数，第一个哈希函数的散列值为初始地址，第二个哈希函数的散列值为地址增量，一次递增，找到空闲单元。 f(key) = (f1(key) + di) MOD m (di = 1 * f2(key), 2 * f2(key),……, (m - 1) * f2(key)) 2. 链地址法将哈希值相同的元素构成一个单链表，存放在哈希表相对应的单元上。链地址法适用于经常进行插入和删除的情况。 3.再哈希法同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 4. 建立公共溢出区这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"bucket sort","slug":"bucket-sort","date":"2020-04-18T00:36:02.000Z","updated":"2020-04-18T01:44:59.000Z","comments":true,"path":"2020/04/17/bucket-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/bucket-sort/","excerpt":"","text":"桶排序之计数排序： 得到无序数组的取值范围 根据取值范围创建对应数量的桶 遍历数组，把每个元素放到对应的“桶”中 按照顺序遍历桶中的每个元素，依次放到数组中，即可完成数组的排序","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"希尔排序（shell_sort）","slug":"shell-sort","date":"2020-04-17T17:50:37.000Z","updated":"2020-04-18T00:08:59.000Z","comments":true,"path":"2020/04/17/shell-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/shell-sort/","excerpt":"","text":"步骤：按一定的增量对数据进行分组，然后对每组进行插入排序，不断减小增量直至增量为1，进行插入排序后整个数据为有序。 123456789101112131415class Solution &#123; public int[] sortArray(int[] nums) &#123; for(int gap = nums.length/2; gap &gt; 0; gap = gap/2)&#123; for(int i = gap; i &lt; nums.length; i++)&#123; int tmp = nums[i]; int j; for(j = i - gap; j &gt;= 0 &amp;&amp; nums[j] &gt; tmp; j = j - gap)&#123; nums[j + gap] = nums[j]; &#125; nums[j + gap] = tmp; &#125; &#125; return nums; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"insertion_sort","slug":"insertion-sort","date":"2020-04-17T17:27:25.000Z","updated":"2020-04-17T17:50:14.000Z","comments":true,"path":"2020/04/17/insertion-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/insertion-sort/","excerpt":"","text":"步骤：每次选择一个元素，将这个元素与之前所有元素比较放在正确的位置上。 12345678910111213class Solution &#123; public int[] sortArray(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++)&#123; int tmp = nums[i]; int j; for(j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; tmp; j--)&#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = tmp; &#125; return nums; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"冒泡排序（bubble_sort）","slug":"bubble-sort","date":"2020-04-17T17:13:34.000Z","updated":"2020-04-17T17:51:37.000Z","comments":true,"path":"2020/04/17/bubble-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/bubble-sort/","excerpt":"","text":"步骤：每次选择两个元素，按照需求进行交换（需要升序排列的话，把较大的元素放在靠后一些的位置），循环n次，这样小的元素会不断的冒泡到前面来，大的元素移动到后面去。 1234567891011121314151617181920class Solution &#123; public int[] sortArray(int[] nums) &#123; boolean ifswap = true; while(ifswap)&#123; ifswap = false; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i + 1])&#123; swap(nums, i, i + 1); ifswap = true; &#125; &#125; &#125; return nums; &#125; private void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"归并排序（merge sort）","slug":"merge-sort","date":"2020-04-17T16:41:32.000Z","updated":"2020-04-17T17:10:00.000Z","comments":true,"path":"2020/04/17/merge-sort/","link":"","permalink":"http://yoursite.com/2020/04/17/merge-sort/","excerpt":"","text":"步骤：如果只有一个元素的情况下直接返回，将数组分成长度尽可能相等的两部分，对左右两部分分别归并排序，然后有序的合并在一起。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;Integer&gt; sortArray(int[] nums) &#123; sort(nums, 0, nums.length - 1, new int[nums.length]); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int num : nums)&#123; result.add(num); &#125; return result; &#125; public void sort(int[] nums, int start, int end, int[] tmp)&#123; if(start &gt;= end)&#123; return; &#125; int mid = (start + end)/2; sort(nums, start, mid, tmp); sort(nums, mid + 1, end, tmp); merge(nums, start, mid, end, tmp); &#125; public void merge(int[] nums, int start, int mid, int end, int[] tmp)&#123; int left = start; int right = mid + 1; int index = start; while(left &lt;= mid &amp;&amp; right &lt;= end)&#123; if(nums[left] &lt;= nums[right])&#123; tmp[index++] = nums[left++]; &#125;else&#123; tmp[index++] = nums[right++]; &#125; &#125; while(left &lt;= mid)&#123; tmp[index++] = nums[left++]; &#125; while(right &lt;= end)&#123; tmp[index++] = nums[right++]; &#125; for(int i = start; i &lt;= end; i++)&#123; nums[i] = tmp[i]; &#125; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"快速排序（quick select）","slug":"quick_select","date":"2020-04-17T05:33:41.000Z","updated":"2020-04-17T05:57:25.000Z","comments":true,"path":"2020/04/16/quick_select/","link":"","permalink":"http://yoursite.com/2020/04/16/quick_select/","excerpt":"","text":"步骤：选取中间元素，把整个数组分成两部分，小于该元素的放在左边，大于该元素的放在右边，分别对左右两边的子数组重复上述操作，直至所有元素有序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;Integer&gt; sortArray(int[] nums) &#123; sort(nums, 0, nums.length - 1); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int num : nums)&#123; result.add(num); &#125; return result; &#125; //quick sort public void sort(int[] nums, int start, int end)&#123; int left = start; int right = end; if(left &gt;= right)&#123; return; &#125; int mid = (left + right)/2; int pivot = nums[mid]; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; &#125; &#125; sort(nums, start, right); sort(nums, left, end); &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"堆排序","slug":"heap_sort","date":"2020-04-17T02:51:24.000Z","updated":"2020-04-17T04:47:32.000Z","comments":true,"path":"2020/04/16/heap_sort/","link":"","permalink":"http://yoursite.com/2020/04/16/heap_sort/","excerpt":"","text":"步骤一：将无序数列构建成最大堆（一般升序采用最大堆，降序采用最小堆）\\ 从最后一个非叶子节点（length/2 - 1）开始，从右至左，从下到上，依次进行调整： 此时将无序序列构建成一个最大堆。 步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。继续调整堆，重复这个过程，直到遍历到第一个元素。 代码实现 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] sortArray(int[] nums) &#123; heapify(nums, nums.length - 1); for(int i = nums.length - 1; i &gt; 0; i--)&#123; int tmp = nums[i]; nums[i] = nums[0]; nums[0] = tmp; siftdown(nums, 0, i - 1); &#125; return nums; &#125; private void heapify(int[] nums, int end)&#123; for(int i = (end + 1)/2 - 1; i &gt;= 0; i--)&#123; siftdown(nums, i, end); &#125; &#125; private void siftdown(int[] nums, int k, int end)&#123; while(2 * k + 1 &lt;= end)&#123; int maxSon = 2 * k + 1; if(2 * k + 2 &lt;= end &amp;&amp; nums[2*k + 2] &gt; nums[maxSon])&#123; maxSon = 2 * k + 2; &#125; if(nums[k] &gt; nums[maxSon])&#123; break; &#125; int tmp = nums[k]; nums[k] = nums[maxSon]; nums[maxSon] = tmp; k = maxSon; &#125; &#125;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-16T05:11:12.000Z","updated":"2020-04-16T20:17:45.000Z","comments":true,"path":"2020/04/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-04-11T18:49:16.000Z","updated":"2020-06-10T02:56:09.000Z","comments":true,"path":"2020/04/11/计算机网络/","link":"","permalink":"http://yoursite.com/2020/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络OSI七层模型 应用层：主要是一些终端的应用，例如浏览器，需要网络流量的应用等。 表示层：对接收的数据进行解释，加密和解密，压缩和解压，将计算机能够识别的东西转化成人能够识别的东西，例如图片，声音等。 会话层：通过传输层定义的端口号建立传输数据的通路。 传输层：定义了一些传输数据的协议和端口号，如TCP，UDP。这一层的数据叫做段。 网络层：将接受的数据进行IP地址的封装和解封装。在这一层工作的设备叫路由器，这一层的数据叫数据包。 数据链路层： **将接受的数据进行MAC地址的封装和解封装。这一层工作的设备为交换机，这一层的数据叫帧**。 物理层： **定义物理设备标准，如网线接口类型，光纤接口类型。传输比特流，这一层的数据叫做比特**。 TCP／IP协议模型 应用层 对应OSI中的应用层，表示层，会话层。应用层决定了向用户提供应用服务时通信的活动。包括HTTP，FTP，DNS服务。 传输层 为两台主机上的应用程序提供端到端的通信。有两个互不相同的传输协议：TCP和UDP。 网络层 也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP／IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议，以及IGMP协议。 链路层 也称作数据链路层和网络接口层,通常包括操作系统中的设备驱动程序和极端及对应的网络接口卡，一起处理电缆的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层的地址。 从URL输入到页面展现到底发生了什么？ DNS服务将域名解析成IP地址 TCP三次握手建立连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 TCP四次挥手断开连接 DNS（域名解析）1. IP地址IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，一次来屏蔽物理地址的差异。域名与IP地址对应，与IP地址的一组纯数字相比，用字母配合数字的表示形式更符合人类的记忆习惯。 2. 什么是域名解析DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务 3. DNS解析流程 浏览器缓存：浏览器会按照一定频率缓存DNS记录 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就去操作系统中找 路由缓存：路由器也有DNS缓存。 ISP的DNS服务器：ISP有专门的应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，向根服务器发出请求，进行递归查询（先问根域名服务器.com域名服务器的地址，然后再问。baidu域名服务器，以此类推） ![](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411194229592.png) 服务器处理请求并返回HTTP报文1. 服务器服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。 ![image-20200411195034559](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411195034559.png) 2. MVC后台处理阶段后台开发有很多框架，大部分是按照MVC设计模式进行搭建的。将应用程序分为三个核心部件：模型（model）-视图（view）-控制器（controller）。 ![image-20200411200029387](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411200029387.png) 1. 视图（view）提供给用户的操作界面。 #####2. 模型（model） 负责数据交互。 3. 控制器（controller）属于管理者的角色，从视图接受请求请决定调用哪个模型去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍浏览器渲染机制 ![image-20200411202942762](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411202942762.png) 根据HTML解析DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每个节点的信息 根据计算好的信息绘制页面 TCP与UDP的区别 TCP面向连接，需要三次握手建立连接来通信，UDP面向非连接，通信前不需要建立连接。 TCP提供可靠服务，UDP不提供可靠服务。 TCP面向字节流，UDP面向报文。 TCP数据传输慢，UDP数据传输快。 TCP粘包的原因和解决办法原因： 发送方将多次发送到缓冲区的数据一次发送出去。 接收端的应用层没有及时读取缓冲区的数据。 处理办法： 发送端给每个数据包的首部添加数据包长度。 发送端将每个数据包封装成固定长度。 可以在数据包之间设置边界，如添加特殊符号。 TCP与UDP对应的协议 TCP对应的协议：HTTP和FTP。 UDP对应的协议：DNS。 TCP与UDP对应的场景 TCP的应用场景：发消息的场景及文件传输，要确保发送的消息不会丢失。 UDP的应用场景：进行视频聊天或者看直播，即使几个画面丢失了，对用户的影响也不是很大。 TCP的三次握手和原因 第一次握手：客户端向服务端发送带有SYN标志的数据包。 第二次握手：服务端向客户端发送带有SYN和ACK标志的数据包。 第三次握手：客户端向服务端发送带有ACK标志的数据包。 ###三次握手的原因 防止已经失效的请求报文又传送到服务端，建立了多余的连接，浪费资源。 为了实现可靠传输，通信双方需要随机产生一个序列号，并把这个起始值告诉对方。 TCP的四次挥手和原因 第一次挥手：主机1（可以是客户端，也可以是服务器端）向主机2发送一个FIN报文段，表示主机1没有数据要发送给主机2了。 第二次挥手：主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，表示同意主机1的关闭请求。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接。 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，主机2收到主机1的ACK报文段以后，就关闭连接。此时主机1等待2MSL后依然没收到回复，则证明服务器端已正常关闭，此时主机1也可以关闭连接。 四次挥手的原因当主机1发出FIN报文段的时候，只是表示主机1已经没有数据要发送了（主机1告诉主机2，他的数据已经全部发送完毕了）；但是这个时候主机1还是可以接受来自主机2的数据，当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还可以发送数据到主机1；当主机2也发送了FIN报文段，这个时候表示主机2也没有数据要发送了。之后中断这次TCP连接。 CLOSE-WAIT存在的意义？让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。 ###TIME-WAIT存在的意义？ 保证客户端发送的最后一个ACK报文能够到达服务器。 是本连接持续时间内产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的报文。 什么情况下TIME-WAIT过多？在高并发短连接的的TCP服务器上，当服务器处理完请求后主动请求关闭，会导致大量socket处于TIME-WAIT状态。 高并发可以使服务器短时间内占用大量端口。 短连接指的是“业务处理时间+传输数据时间”远小于TIME-WAIT时间。在关闭连接之后，短连接业务使用过的端口会停留在TIME-WAIT状态，在这段时间内，其他短连接请求来临时是无法占用此端口的。 如何查看TIME-WAIT状态的链接数量？ 用netstat指令：#netstat -n | awk ‘/^tcp/ {++S[$NF]} END { for(a in S) print(a,S[a])}’ 如何解决TIME-WAIT过多？通过调整以下内核参数的办法解决TIME-WAIT过多： net.ipv4.tcp_syncookies = 1 ：表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可以防范少量SYN攻击。 net.ipv4.tcp_tw_reuse = 1：表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。 net.ipv4.tcp_tw_recycle = 1 ：表示开启TCP连接中TIME-WAIT sockets的快速回收。 net.ipv4.tcp_fin_timeout：修改系统默认的TIMEOUT时间。 ##TCP与 UDP TCP传送的协议数据单元是 TCP 报文段（segment） UDP传送的协议数据单元是 UDP 报文 或用户数据报 TCP如何实现可靠传输 应用数据被分割成TCP认为最适合发送的数据块。 TCP给发送的每一个数据包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 TCP将保持他的首部和检验和，如果收到数据包的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 TCP的接收端会丢弃重复的数据。 TCP利用滑动窗口进行流量控制。 TCP使用拥塞控制避免网络拥塞。 使用ARQ协议实现可靠传输。 使用超时重传实现可靠传输。 停止等待ARQ协议原理是每发送完一个分组就停止发送，等待对方确认。如果过了一段时间后还没收到确认，说明没发送成功，需要重新发送。 优点：简单 缺点：信道利用率低。 ##连续ARQ协议 发送端维护一个一定大小的滑动窗口，位于滑动窗口内的分组可以连续发送出去，不需要等待对方确认。接收方一般采取累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。 优点：信道利用率高。 缺点：不能向发送方反映出接收方已经正确收到的所有分组信息。比如：发送方发送了五个分组，其中第三个分组丢失，接受方只能收到前两个分组的确认，后三个分组只好重传。 TCP滑动窗口与流量控制发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。 TCP拥塞控制如果网络出现拥塞，分组将丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。应该控制发送方的速率。 ![image-20200412133717718](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412133717718.png) TCP主要通过四个算法来进行拥塞控制：慢开始，拥塞避免，快重传，快恢复。 发送方需要维护一个叫做拥塞窗口的状态变量。 1. 慢开始与拥塞避免发送的最初执行慢开始，令cwnd = 1，发送方指发送一个报文段；当收到确认后，将cwnd加倍，因此之后发送方能够发送的报文段数量为：2，4， 8… 慢开始每一轮都将cwnd加倍，发送方发送的速度增长过快，网络拥塞可能性更高。设置一个慢开始门限ssthresh，当send &gt;=ssthresh时，进入拥塞避免，每个轮次只将cwnd加1。如果出现超时，则令ssthresh = cwd／2，然后重新执行慢开始。 2. 快重传与快恢复接收方每次接受到报文段都应该对最后一个已收到的有序报文段进行确认，如果发送方收到三个重复确认，就可以判定下一个报文段丢失，此时执行快重传，立即传送下一个报文段。 这种情况下执行快恢复，令ssthresh = cwnd／2，cwnd = ssthresh，此时直接进入拥塞避免。 ![image-20200412135352055](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200412135352055.png) IP报文格式TCP与HTTP区别Tcp对应传输层，Http对应应用层，Http协议作用于Tcp协议之上。当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求，Http会通过Tcp建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将Tcp连接断开。 SocketSocket是应用层与TCP／IP协议族通信的中间软件抽象层，它是一组接口，把复杂的TCP／IP协议族隐藏在Socket接口后面。 HTTPHTTP是什么？通俗地讲，HTTP是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP／IP协议传输数据。 四个基于：请求与响应：客户端发送请求，服务器端响应数据 无状态：客户端向服务器端发起请求时，每次都是建立一个新的连接。每次请求结束后，连接就关闭，相关的内容就释放了，记不住任何状态，成为无状态连接。 应用层：Http属于应用层协议，配合TCP／IP使用。 TCP／IP：Http使用TCP作为它的支撑运输协议。HTTP客户端发起一个与服务器的TCP连接。 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据组成。 ![image-20200411114814725](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411114814725.png) 1. 请求行（request line）请求行分为三部分：请求方法，请求地址，协议版本。 ####2.请求头部 请求头部为报文添加一些附加信息，由“名／值”对组成，每行一对，名和值之间使用冒号分隔。请求头部的最后会后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据可选部分，比如GET请求就没有请求数据。 HTTP响应报文HTTP响应报文主要由状态行，响应头部，空行以及响应数据组成。 1. 状态行由三部分组成，分别为：协议版本，状态码，状态码描述 2. 响应头部与请求头部类似，为响应报文添加了一些附加信息 3. 响应数据用于存放需要返回给客户端的数据信息 HTTPS中的对称加密和非对称加密对称加密就是加密和解密用的是同一个密钥k。 非对称加密是发送端使用公开的公钥a加密，然后接收端使用私密的私钥b解密。 HTTPS请求的过程 首先，浏览器请求一个url，找到服务器，向服务器发起一个请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类及其他相关信息返回客户端。 浏览器检查CA证书是不是由可以信赖的CA机构颁发的，确认证书有效和此证书实测网站的。如果不是，给客户端发一个警告，询问是否继续访问。 如果是，客户端使用公钥加密一个随机对称密钥，包括加密的URL一起发送到服务器。 服务器用自己的私钥解密了客户端发送的钥匙，然后用内部包含的对称加密的钥匙给你请求的URL连接解密。 服务器用客户端发来的对称钥匙给请求的网页加密。客户端有相同的钥匙，可以解密传送回来的网页。 HTTP协议的发展历程###HTTP1.0与HTTP1.1的一些区别 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since, Expires作为缓存判断标准，在HTTP1.1中引入了更多的缓存控制策略例如：Entity tag，if-Unmodified-Since，If-Match，If-None-Match。 充分利用带宽和网络连接：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却把整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回吗是206（partial content）。 错误状态响应码：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 长连接：在HTTP1.0中默认使用短连接，也就是说每次请求都要重新建立一次连接。HTTP1.1起默认使用长连接，可以用一个链接发送多个请求。有流水线和非流水线两种方式。流水线方式是指客户端在接受到HTTP响应报文之前就可以继续发送新的请求报文，非流水线方式是指客户端在收到一个响应之后才可以发送下一个请求。 HTTP2.0 新的二进制格式：HTTP1.X的解析是基于文本的，文本的表现形式有多样性，要考虑的场景有很多。二进制只有0和1的组合，实现方便。 多路复用：多个请求共享一个TCP连接，每个请求对应一个id，接收方可以根据每个请求对应的id将请求归属到不同的服务端请求里面。 header压缩：客户端和服务端同时维护和更新一个包含之前见过的首部字段表，避免重复传输。 服务端推送：在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不会再次发起请求了。例如：客户端请求page.html页面，服务端就把script.js和style.css等与之相关的资源一起发给客户端。 HTTPs和HTTP的区别HTTP协议传输的数据都是未加密的，可以用抓包工具直接抓下来，而HTTPS利用SSL协议对HTTP协议传输的数据进行加密，抓包工具抓下来的是密文，增加了中间人攻击的成本。 HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的，HTTP 无法加密，而HTTPS 对传输的数据进行加密 HTTP 标准端口是80 ，而 HTTPS 的标准端口是443 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层 HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书 HTTP的请求过程![image-20200411125933423](/Users/wangyuchen/Library/Application Support/typora-user-images/image-20200411125933423.png) Cookie和Session的区别 Cookie用来保存用户信息。比如：（1）在Cookie中保存已经登陆过的用户信息，下次访问网站时自动把登陆的信息填好。（2）一般的网站有保持登陆，也就是下次访问的时候不用登录了。 Session通过服务端记录用户的状态。比如购物车，当添加商品到购物车时，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的Session后就可以标识这个用户并且跟踪这个用户了。 Cookie数据存储在客户端，Session数据存储在服务器端。相对来说Session安全性更高。如果要在Cookie中存储一些敏感信息，不要直接写入Cookie，最好先将Cookie信息加密然后使用到的时候再去服务端解密。 GET和POST比较作用GET用于获取资源，POST用于传输实体主体。 ###参数 GET和POST请求都可以使用额外的参数。GET的参数是以查询字符串的形式出现在URL中，因为URL只支持ASCII码，因此GET的参数中如果存在中文等字符就需要先进行编码。并且URL的长度是受限制的（URL最大长度是2048个字符）。POST的参数存储在实体主体中，支持标准字符集。 幂等性幂等的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器的状态也是一样的。GET方法是幂等的，POST方法不是。 可缓存性GET能被缓存，POST不能缓存 转发和重定向的区别 转发是服务器行为，把一个request／response的处理权移交给了另一个。 重定向是客户端行为，客户端给服务器A发送请求，服务器响应，告诉浏览器应该去B，这个时候浏览器定位到新的URL。 HTTP状态码 301:永久重定向。采用新的URL 302:临时重定向。采用新的URL，URL以后可能发生改变。 304:请求的资源没有改变，可以使用缓存。 504:网关超时，接受服务器未能从远端服务器及时获取响应。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统","slug":"operating system","date":"2020-04-05T06:19:31.000Z","updated":"2020-06-08T04:47:32.000Z","comments":true,"path":"2020/04/04/operating system/","link":"","permalink":"http://yoursite.com/2020/04/04/operating%20system/","excerpt":"","text":"operating system定义与基本概念操作系统是连接计算机硬件与软件的中间层。 因此操作系统分为两种状态： 用户态：系统权限低，只可读取应用程序的数据。 内核态：系统权限高，几乎可以访问系统的任何资源，不受限制。 线程和进程 拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度。线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程，会引起进程切换。 系统开销方面。创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I／O设备等，所付出的开销远大于创建或撤销进程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小 线程间可以通过直接读取统一进程中的数据进行通信，但是进程通信需要借助IPC 协程协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。适用于被阻塞且大量并发的场景。 与线程的区别 线程占用资源相对协程较大。一个线程可以有多个协程。 线程由操作系统内核调度，切换开销大；协程由用户调度，切换开销小。 线程需要锁来保持数据同步，协程不需要锁机制。 ##线程的七态模型： 初始状态 就绪状态 运行状态 阻塞状态 锁池状态 等待队列 终止状体 用户态和内核态当一个进程在执行自己的代码时处于用户态，特权级最低。当执行一些与系统有关的操作时由内核态来完成，特权级高。切换到内核的方式有：系统调用，发生异常，外围设备的中断。 进程空间：内核态内存空间，用户态堆栈，数据段，进程代码段， 线程共享的有：进程代码段，进程共享数据，文件描述符，信号处理器，进程当前目录，进程用户ID，进程组ID 线程私有的：线程ID，寄存器的值，线程的栈，线程优先级，线程返回码，线程信号屏蔽码。 进程间同步与互斥的区别，线程同步的方式 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 ###进程同步的方式： 临界区：同一时刻只有一个进程可以访问临界区 互斥量：同一时刻只有一个线程可以访问同一资源。 信号量：同一时刻多个线程访问同一资源。 管程: 把信号量的控制代码独立出来，更容易控制。 线程同步的方式： 互斥量：互斥量可以解决多个进程之间线程互斥问题。 信号量：允许多个线程在同一时刻访问同一资源。 事件：通知操作的方式保持线程同步。 进程的通信方式 管道：又称匿名管道，存在于内存中 只用于具有亲缘关系的父子进程或兄弟进程间的通信w 无格式，先进先出，单向 有名管道：存在磁盘中 可用于本机任意两个进程间的通信 无格式，先进先出，单向 信号：通知接收进程某个事件的发生 用于快速响应 只有一种格式类型 消息队列：存在内核中，只有在内核重启或者显示删除，消息队列才会被真正的删除。 消息队列克服了信号信息量少，管道只能承载无格式字节流及缓冲区大小受限等局限。 消息具有的特定的格式和优先级，可以顺序读，也可以按照类型或优先级读取。 消息队列独立于读写进程，读写可以异步。即写入的时候可以没有读进程，读的时候可能写进程已经结束。 信号量：信号量是一个计数器，用于多进程对共享数据的访问，用于进程间的同步。 *共享内存： *多个进程共享同一块内存空间 最快的进程间通信方式 多个进程可以操作共享内存，因此必须进行同步 套接字：用于不同主机间进程的双向通信。 内存管理1. 段／页式管理简单分为连续分配管理方式和非连续分配管理方式，连续分配管理方式指为一个用户程序分配一个连续的内存空间，常见的如块式管理。同样地，非连续分配管理方式允许一个程序使用的内存分布在不相邻的内存中，常见的如页式管理和段式管理。 1. 块式管理：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，系统就分配给它一块。这种方式会造成浪费。 2. 页式管理：把主存分为**大小相等且固定**的一页一页的形式，页较小，相比于块式管理划分力度更大，提高了**内存利用率**，减少了**碎片**。页式管理通过**页表**建立**逻辑地址**到**物理地址**的映射。 3. 段式管理：把主存分为一段一段的形式，每段的**大小不一**，由相应的**逻辑信息组**的长度决定，并且可以**动态增长**。段式管理通过**段表**建立**逻辑地址**到**物理地址**的映射。 4. 段页式管理：结合了段式管理和页式管理的优点。主存划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。段式存储和页式存储的共同点和区别： 共同点： 分页制和分段制都是为了提高内存利用率，减少内存碎片。 页和段都是离散存储的，但是，每个页和段中的内存是连续的。 区别： 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。 分页仅仅是为了满足操作系统内存管理的要求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段等等，能够更好地满足用户的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。 页式系统的地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个标识符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。 段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。 2. 虚拟内存产生背景： 对于进程来说，直接操作物理地址，会有如下问题： 数据覆盖：同一物理地址，可能a，b进程都在使用，a写数据，有可能被b覆盖。 数据重复：对不同进程来说，可能存在相同的数据，存在同一份数据多处存储的现象。 难以连续存放：程序往往需要占用连续内存，而这需要实时地对现有的逻辑地址空间进行判断和协调，也容易造成浪费 内存空间不统一：需要人为指定所占用的逻辑地址空间，不同程序的需求不一样。 解决思想： 在物理地址空间上包一层虚拟地址空间，虚拟内存的作用，就是屏蔽底层物理内存的操作细节，让每个进程感受不到其他进程的存在。 具体细节： 每个进程都分配相同的虚拟内存空间，如都为4GB。进程数据都过虚拟内存，映射到当前可用的物理内存，这样每个程序都拥有自己独立的虚拟地址空间，不存在数据覆盖问题，因为操作系统在建立虚拟内存到物理内存的映射时，会避免各个进程在物理内存上的相互干扰。 虽然在虚拟内存空间里，进程的数据是连续存放的，但映射后的物理内存却不必连续，可充分利用碎片资源。对于多个进程公用的内存，在物理内存中可以只存一份，不同进程使用时只需建立到该物理内存的映射即可，降低了数据的重复。 问题： 假设现在物理内存为4GB，两个进程a，b的虚拟内存都是4GB，虚拟内存之后大于实际物理内存的容量，内存会不够用，这时会把多余的指令或数据放在磁盘里。 装载程序时，只将当前指令所需的部分页面放入内存中，其余放在磁盘里 运行时发现所需指令或数据不在内存中：缺页中断，cpu通知操作系统从磁盘中将相应的页面或段加载到内存里 从磁盘调入页面到内存时发现内存不够用：页面置换，即将当前内存中不用的页放到磁盘中，将需要的页放进来 这样，虚拟内存就用有限的内存满足了超过实际物理内存容量的需求。 虚拟页表： 虚拟内存通过虚拟页表映射到物理内存。由MMU（内存管理单元）维护。每个进程维护一个单独的虚拟页表，通过虚拟地址，找到虚拟页表中存放的物理地址，再通过该物理地址，找到存储在内存中的数据。因此，虚拟页表中的页有三种状态： 未映射的页：虚拟页的值为nil。 已映射外存：但外存的的数据还没缓存到内存中。 已映射内存：即外存数据已经缓存到内存中。 虚拟地址为16位，由页号+页内偏移构成。 页号：4位，前三位为索引，最后一位表示是否在内存中，1代表在内存中，0表示不在。 页内偏移：12位，与页中存储的物理页号组合，构成物理地址。这意味着，页的大小为4kb。 快表与分级页表： 为加快虚拟地址到物理地址的转换速度，引入了快表的概念。快表相当于页表的缓存，细节如下： 根据虚拟地址中的页号查快表； 如果该表在快表中，直接从快表中读取相应的物理地址； 如果该页不在快表中，就访问内存中的页表，再从页表中的到物理地址，同时将页表中的该映射表项添加到快表中； 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的页。 内存宝贵，页表可能会比较大，因此又引入了多级页表的概念。在实际运行时，程序并不会用到全部内存空间，有的以及页表下面没有二级页表。这样页表就得到了精简。 二级页表也可以放入磁盘中，在需要的时候调入内存。当然，分级页表的代价是时间，多级查询和磁盘置换都会造成耗时，因此这是一种典型的时空权衡。 页面置换算法在程序运行过程中，如果要访问的页不在内存中，就会发生缺页中断从而将该页调入内存。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 最近最少使用（LRU）：换掉最近最不常用的页。 实现：在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移动链表表头。这样就能保证链表表尾的页面最近最不常用。因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高。 最近未使用（NRU）：每个页面都有两个状态位：R与M，当页面被访问时设置页面的R=1，当页面被修改时设置M=1.其中R位会被定时清零。可以将页面分成以下四类。 R = 0， M = 0 R = 0， M = 1 R = 1， M = 0 R = 1， M = 1 NRU优先换出已经被修改的脏页面（R = 0， M = 1），而不是被频繁使用的干净页面（R = 1， M = 0） 先进先出（FIFO）：页面用链表先后依次连接，每次淘汰内存中最老的页面，即链表的第一个元素，该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 第二次机会算法（second chance）：当页面被访问时，设置该页面的R位为1.替换时，检查最老页面的R位。如果R位是0，可以立刻置换掉；如果是1，就将R位清0，并将其移动到链表尾部，相当于再给一次机会。 时钟算法：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老页面。 进程调度算法1. 批处理系统批处理系统没有太多的用户操作，调度算法的目标是保证吞吐量和周转时间。（从提交到中止的时间）。 1.1 先来先服务算法 first-come first-served（FCFS）依据进程进入就绪状态的先后顺序排列。 有利于长作业，不利于短作业。因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业需要执行很长时间，造成了短作业等待时间过长。 1.2 短进程优先算法shortest job first（SJF）按估计运行时间最短的顺序进行调度。 长作业一直等待短作业执行完毕，如果一直有短作业来，长作业有可能饿死。 1.3 最短剩余时间优先 shortest remaining time next（SRTN）按剩余时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间做比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。 2. 交互式系统2.1时间片轮转算法将所有就绪进程按照FCFS规则的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片，当时间片用完时，由计时器发出时钟中断，调度程序中止该进程的执行，并将它送往就绪队列的末尾，同时把CPU时间分配给队首进程。 2.2 优先级调度为每个进程分配一个优先级，按照优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 3.3 多级反馈队列设置多个队列，每个队列优先权不同，时间片大小不同。最上面的队列优先级最高，时间片最小。进程在第一个队列没执行完，就会被移到下一个队列。 Linux中几种IO模型（select，poll，epoll）1. 阻塞和非阻塞IO调用阻塞IO会一直阻塞对应的进程直到操作完成。 非阻塞IO会在内核还在准备数据的情况下离开返回。 ###2. 同步和异步IO 同步IO在执行IO操作时进程会被阻塞。 异步IO发起IO操作后，就直接返回再也不理睬，直到内核发送一个信号，告诉进程IO完成。 3. 多路复用IOselect, poll,epoll这个function不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 死锁条件 互斥：一个资源每次只能被一个进程使用。 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不可强行占有：进程已获得的资源，在未使用完之前，不可强行占有。 循环等待：若干进程之间形成一种头尾相连的循环等待资源关系。 处理方法： 鸵鸟策略：忽略死锁。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行回复。 每种类型一个资源的死锁检测是通过检测资源分配图中是否有环来检测死锁的发生。 每种类型多个资源的死锁检测： E向量：资源总量 A向量：资源剩余量 C矩阵：每个进程所拥有的资源数量。 R矩阵：每个进程请求的资源数量 算法总结： 寻找一个没有标记的进程，它所请求的资源小于等于剩余资源，如果找到这样的进程，则将该进程的值加回到剩余资源中，标记该进程为1，继续寻找未标记的进程。如果没有找到这样一个进程，则算法终止，所有未被标记的进程都是死锁进程。 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 死锁预防：在程序运行之前预防发生死锁： 破坏互斥条件 破坏占有和等待条件：一种实现方式是规定所有进程在开始执行之前请求所需要的全部资源。 破坏不可抢占条件 破坏环路等待条件：给资源统一编号，进程只能按照编号顺序来请求资源。 死锁避免：在程序运行时避免发生死锁： 1. 安全状态：定义：存在某种调度次序能够使每个进程运行完毕，则称该状态是安全的。 2. 单个资源的银行家算法：判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求，否则分配。 3. 多个资源的银行家算法：查看是否存在进程请求资源的值小于剩余资源，如果有，则标记这个进程终止，并把资源分配回剩余资源中，假如不存在这样的资源，则进入不安全状态。 Linux的五种IO模型 阻塞IO（blocking IO）：用户进程调用recv()/recvfrom(),内核开始准备数据，当数据准备好时，系统会将数据从内核拷贝到用户内存。整个过程中进程被阻塞。 非阻塞IO（nonblocking IO）：用户进程调用recv()/recvfrom()后进程没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。重复调用recv()直到内核中数据准备好，然后将内核数据拷贝到用户内存。 多路复用IO（IO multiplexing）：利用select／poll／epoll对多个IO端口进行监听，当其中一个socket的数据准备好了，就会返回可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户内存。有点是利用单个进程监视多个文件描述符，与多进程和多线程技术相比，此技术的特点是系统开销小，系统不必创建和维护线程或进程。 信号驱动式IO（signal-driven IO）: 调用信号处理函数，不等待数据就绪就立即返回，进程继续执行，当数据准备好时，进程会收到一个SIGIO信号，此时调用Recv（）函数进行数据拷贝。 异步IO（asynchronous IO）：用户进程进行aio_read系统调用后，无论数据是否准备好，都会直接返回给用户进程，用户进程不会被阻塞。等到数据准备好之后内核直接将数据复制给进程并发送信号进行通知。 select，poll和epoll： select：每次调用的时候，都需要把文件描述符集合从用户态拷贝到内核态，都需要在内核遍历传递进来的所有文件描述符，且内核对被监控的文件描述符集合的大小做了限制，为1024. Poll：文件描述符的数据结构从fd_set变成了pollfd，没有了最大文件描述符大小的限制，其他和select一致。 ePoll：最大连接数没有限制，保证了每个fd在整个过程中只拷贝一次，并且采用事件通知机制，每当fd就绪时，系统注册的回调函数就会被调用，将就绪的fd放到就绪队列中。 fork()函数 fork()函数fork之后，操作系统会复制一个与父进程完全相同的子进程，这两个进程共享代码空间，但是数据空间是相互独立的，子进程的数据空间中的内容是父进程的完全拷贝，指令指针也完全相同，子进程拥有父进程当前运行的位置。不同的地方时，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork复制不成功，父进程会返回错误。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"-计算机","slug":"计算机","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"-数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"-数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}